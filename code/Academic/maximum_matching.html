<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131511873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131511873-1');
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
$\newcommand{\O}{\mathrm{O}}$

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title> My Algorithm : kopricky アルゴリズムライブラリ </title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="競技プログラミングで使われるアルゴリズムのコード集">
<meta name="keywords" content="競技プログラミング,競プロ,アルゴリズム,コード,kopricky,computation,datastructure,geometry,graph,networkflow,string,icpc,Atcoder">
<link rel="stylesheet" href="../../css/style.css">
<script type="text/javascript" src="../../js/openclose.js"></script>
<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="../../css/prettify.css" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>

<div id="container">

<header>
<h1 id="logo"><a href="../../index.html"><img src="../../images/logo.png" alt="kopricky アルゴリズムライブラリ"></a></h1>
</header>


<nav id="menubar">
<ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../guide.html">Guide</a></li>
<li class="current"><a href="../../code.html">Code</a></li>
<li><a href="../../link.html">Link</a></li>
</ul>
</nav>

<div id="contents">

<section>
<h2>Maximum Unweighted Matching Algorithm</h2>
<h3>コードについての説明</h3>
<p>
一般グラフの重みなし最大マッチングを求める乱択アルゴリズム. 最大マッチングを求めるアルゴリズムとしては Edmonds の花分解アルゴリズムが有名であるが, 同時に $\O (n^3)$ の乱択アルゴリズムも知られており, 以下はその実装となっている(<a href="http://theory.stanford.edu/~virgi/cs367/oldlecs/lecture9.pdf">参考1</a>, <a href="http://theory.stanford.edu/~virgi/cs367/oldlecs/lecture10.pdf">参考2</a> を参照しました). 実測はそんなに良くないが numeric に解けるので個人的に好き.<br>
グラフ $G$ が完全マッチングを持つことと $G$ の Tutte 行列の行列式が恒等的に非ゼロであることの同値性を用いる. $\det$ 計算における置換に注目すると奇閉路(奇数位数の軌道)の存在する項は逆向きの項と打ち消し合って消え, 偶閉路のみからなる項のみ残りうる. もし偶閉路のみからなる非ゼロの項が残った場合はグラフ $G$ 上で対応する完マを取ることができるので "Tutte 行列の行列式が非ゼロ $\rightarrow$ $G$ は完マを持つ" が成り立つ.<br>
また逆にグラフ $G$ に完マが存在するならそれに対応して Tutte 行列の行列式に偶閉路のみからなる非ゼロ項が存在し, その項は他の項と打ち消し合って消えることはない. よって "$G$ は完マを持つ $\rightarrow$ Tutte 行列の行列式が非ゼロ" も成り立つ. <br>
よって $n$ 次の多変数多項式($\det T$) が恒等的に $0$ であることが判定できれば良いのだが deterministic に行おうとすると効率的に解けないため各変数に乱数を代入し, その結果が $0$ に等しいかどうかで判定する($\mathbb{Z}_p$ 上で行う). <br>
Shwartz-Zippel Lemma より $\det T$ が恒等的に $0$ でないのに上記の計算結果が $0$ になってしまう(完全マッチングを持つのに持たないと判定する)確率は $\O (n / p)$ となり, 例えば $n = 10^2$, $p = 10^9 + 7$ のときは $1$ 度の試行で十分である(不安なら $LOOP$ の値を大きくする). <br>
(注) $G$ の最大マッチングの数は $\mathrm{rank} (T) / 2$ に等しい($\mathrm{rank}$ が $r$ の交代行列は $r \times r$ の正則な主小行列を持つことから言える $\Rightarrow$ 補足 1). <br>
<br>
(構築の話) <br>
構築だがグラフが完全マッチングを持つという条件を保ったまま縮小していくことをする. ただし $G$ が完全マッチングを持たない場合は Gaussian elimination を用いて Tutte 行列の中に含まれる $\mathrm{rank} (T) \times \mathrm{rank} (T)$ の正則な主小行列を事前に求めておく.
愚直に全辺についてそれを除いたグラフが完全マッチングを持つかどうかを調べていくと $\O (n^5)$ かかる. <br>
行列 $T$ から $\{ u_1, \ldots, u_k \} \subseteq [n]$ に含まれる添字の行および $\{ v_1, \ldots, v_l \} \subseteq [n]$ に含まれる添字の列を削除したものを $T_{ \langle u_1 \ldots, u_k \rangle , \langle v_1 \ldots, v_l \rangle }$ と書くことにする. $\det T$ を $1$ 行目で余因子展開したものを
$\det (T) = \sum_{j=1}^n (-1)^{i+j} T_{1, j} \det (T_{\langle 1 \rangle, \langle j \rangle})$ と表せ, $\det T \neq 0$ なら $T_{1,j} \neq 0$(辺 $(1, j)$ が存在する) で $\det (T_{ \langle 1 \rangle ,\langle j \rangle }) \neq 0$ となるものが存在する. <br>
また $\det (T_{\langle 1 \rangle ,\langle j\rangle }) \neq 0 \Rightarrow \det (T_{ \langle 1,j \rangle ,\langle 1,j \rangle }) \neq 0$ より辺 $(1, j)$ を取り除いた後のグラフは完全マッチングを持つ($\Rightarrow$ 補足 2). <br>
あとは $\det (T_{ \langle 1 \rangle ,\langle j \rangle }) \neq 0$ となるような $j$ をどうやって見つけてくるかだが $(T^{-1})_{i, j} = (-1)^{i+j} \cdot \frac{\det \left( {T_{\langle i \rangle, \langle j \rangle}} \right)}{\det \left( T \right) }$ より, $\det (T_ { \langle 1 \rangle ,\langle j \rangle }) \neq 0 \Leftrightarrow \left( T^{-1} \right) _{1,j} \neq 0$ が得られるので $T$ の逆行列を計算することで $j$ を求めることができる. <br>
これを再帰的に繰り返すことで $\O (n^4)$ で構築することが可能になった(正確には $\O (n^{ω+1})$ time). <br>
ここで逆行列計算を毎回する必要はなく $T^{-1}$ をブロック行列と見てその Schur 補行列が $\left( T_ { \langle i,j \rangle ,\langle i,j \rangle } \right) ^ {-1}$ と一致するので辺を取り除いた後の Tutte 行列の逆行列は $T^{-1}$ が求まっていると $\O (n^2)$ 時間で構築することができる.
つまり全体で $\O (n^3)$ time で計算可能. ちなみにもっと頑張ると $\O (n^ω)$ まで落ちるらしい<br>
<br>
以下では交代行列の性質を用いて導かれる本文中の自明でない結果 (補足 1), (補足 2) について証明を雑に記す. <br>
証明は (補足 1) の方は随分前に何かの資料で見て知ったのだが、出典を覚えていない. (補足 2) の方は参考資料に基づく. <br>
(補足 1) <br>
$\mathrm{rank}$ が $r$ の交代行列 $A \in \mathbb{R}^{n \times n}$ が $r \times r$ の正則な主小行列を持つことを示す.
$A$ の固有多項式を考える. すると $\det (xI - A) = \underset{\sigma}{\sum} \mathrm{sign} (\sigma) (xI - A)_{i, \sigma(i)} = \sum_{0 \le k \le n} \underset{X \subseteq [n], |X| = n - k}{\sum} \det (A_{X, X}) x^k$ が言える.
$2$ つ目の等式は $k = | \{ i \mid \sigma(i) = i \} |$ について足し合わせる &amp; $A$ の対角成分は交代行列なので $0$ である ことに注意すると成り立つことが分かる. <br>
交代行列は正規行列であることから対角化可能であり, 固有値の幾何的重複度と代数的重複度が一致するため, 今 $r = \mathrm{rank} A$ から固有多項式の最小の非ゼロ係数項の指数は $n - r$ となる.
つまり $\exists X \subseteq [n], |X| = r$ について $\det (A_{X, X}) \neq 0$ が成り立つ.
<br>
(補足 2) <br>
$\det (T_{\langle 1 \rangle ,\langle j\rangle }) \neq 0 \Rightarrow \det (T_{ \langle 1,j \rangle ,\langle 1,j \rangle }) \neq 0$ を示す. <br>
初めに以下に証明に用いる交代行列に関するフロベニウスの定理を記す. <br>
$A \in \mathbb{R}^{n \times n}$ を交代行列とし, $\alpha, \beta \subseteq [n]$ を $|\alpha| = |\beta| = \mathrm{rank}(A)$ を満たすインデックスの集合とする.
このとき $\det (A_{\alpha, \alpha}) \det (A_{\beta, \beta}) = (-1)^{|\alpha|} \det (A_{\alpha, \beta})^2$ が成り立つ. <br>
これを用いて定理を示す. <br>
まず $j = 2$ として一般性を失わない.
$n$ が奇数のとき交代行列の行列式は $0$ となるので $T_{\langle 1 \rangle, \langle 1 \rangle } = 0$ であるが, 仮定より $T_{\langle 1 \rangle, \langle 2 \rangle } \neq 0$ なので
$T_{\langle 1 \rangle, \langle 1, 2 \rangle }$ は列フルランクである. よって $\mathrm{rank} \left( T_{\langle 1 \rangle, \langle 1 \rangle } \right)$ は $n-2$ となる. さらに $\beta = \{ 3, \cdots, n \}$ としたとき, $\exists \alpha \subseteq \{ 2, \cdots, n \}, |\alpha | = n - 2$
で $A_{\alpha, \beta}$ が正則となるようなものが存在することも分かる.
最後にフロベニウスの定理より, $\det (A_{\alpha, \beta}) \neq 0 \Rightarrow \det (A_{\beta, \beta}) \neq 0$ が導けるので確かに $\det \left( T_{\langle 1, 2 \rangle, \langle 1, 2 \rangle } \right) \neq 0$ が言える.<br>
</p>
<p>
(関数)<br>
add_edge() : 辺を追加する <br>
perfect_matchching() : 完全マッチングがどうかの判定 <br>
maximum_matching() : 最大マッチングの数を返す <br>
find_maximum_matching() : 最大マッチングの数を計算し, その組を返す <br>
</p>
<p>
時間計算量: $\O (n^3)$
</p>
<h3>コード</h3>
<div class="codebox">
<input type="checkbox" id="label" class="csscode" />
<label for="label"></label>
<pre class="prettyprint linenums">
template &lt;unsigned int mod&gt;
class ModInt {
private:
    unsigned int v;
    static unsigned int norm(const unsigned int&amp; x){ return x &lt; mod ? x : x - mod; }
	static ModInt make(const unsigned int&amp; x){ ModInt m; return m.v = x, m; }
    static ModInt inv(const ModInt&amp; x){ return make(inverse(x.v, mod)); }
    static unsigned int inverse(int a, int m){
        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;
        while(*v){
            t = *u / *v;
            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);
        }
        return (u[1] % m + m) % m;
    }

public:
    ModInt() : v{0}{}
    ModInt(const long long val) : v{norm(val % mod + mod)} {}
    ModInt(const ModInt&lt;mod&gt;&amp; n) : v{n()} {}
	explicit operator bool() const noexcept { return v != 0; }
    bool operator!() const noexcept { return !static_cast&lt;bool&gt;(*this); }
    ModInt&amp; operator=(const ModInt&amp; n){ return v = n(), (*this); }
    ModInt&amp; operator=(const long long val){ return v = norm(val % mod + mod), (*this); }
    ModInt operator+() const { return *this; }
    ModInt operator-() const { return v == 0 ? 0 : mod - v; }
    ModInt operator+(const ModInt&amp; val) const { return make(norm(v + val())); }
    ModInt operator-(const ModInt&amp; val) const { return make(norm(v + mod - val())); }
    ModInt operator*(const ModInt&amp; val) const { return make((long long)v * val() % mod); }
    ModInt operator/(const ModInt&amp; val) const { return *this * inv(val); }
    ModInt&amp; operator+=(const ModInt&amp; val){ return *this = *this + val; }
    ModInt&amp; operator-=(const ModInt&amp; val){ return *this = *this - val; }
    ModInt&amp; operator*=(const ModInt&amp; val){ return *this = *this * val; }
    ModInt&amp; operator/=(const ModInt&amp; val){ return *this = *this / val; }
    ModInt operator+(const long long val) const { return ModInt{v + val}; }
    ModInt operator-(const long long val) const { return ModInt{v - val}; }
    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }
    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }
    ModInt&amp; operator+=(const long long val){ return *this = *this + val; }
    ModInt&amp; operator-=(const long long val){ return *this = *this - val; }
    ModInt&amp; operator*=(const long long val){ return *this = *this * val; }
    ModInt&amp; operator/=(const long long val){ return *this = *this / val; }
    bool operator==(const ModInt&amp; val) const { return v == val.v; }
    bool operator!=(const ModInt&amp; val) const { return !(*this == val); }
    bool operator==(const long long val) const { return v == norm(val % mod + mod); }
    bool operator!=(const long long val) const { return !(*this == val); }
    unsigned int operator()() const { return v; }
    friend ModInt operator+(const long long val, const ModInt&amp; n) { return n + val; }
    friend ModInt operator-(const long long val, const ModInt&amp; n) { return ModInt{val - n()}; }
    friend ModInt operator*(const long long val, const ModInt&amp; n) { return n * val; }
    friend ModInt operator/(const long long val, const ModInt&amp; n) { return ModInt{val} / n; }
    friend bool operator==(const long long val, const ModInt&amp; n) { return n == val; }
    friend bool operator!=(const long long val, const ModInt&amp; n) { return !(val == n); }
    friend istream&amp; operator&gt;&gt;(istream&amp; is, ModInt&amp; n){
        unsigned int v;
        return is &gt;&gt; v, n = v, is;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const ModInt&amp; n){ return (os &lt;&lt; n()); }
    friend ModInt power(ModInt x, long long n){
        ModInt ans = 1;
        while(n){
            if(n &amp; 1) ans *= x;
            x *= x, n &gt;&gt;= 1;
        }
        return ans;
    }
};

template&lt;typename T&gt; class mat : public vector&lt;vector&lt;T&gt; &gt; {
private:
    int r, c;    //行,列
public:
    inline int row() const { return r; }
    inline int column() const { return c; }
    mat(const int n) : mat(n, n, 0){}
    mat(const int n, const int m, T val = 0)
        : vector&lt;vector&lt;T&gt; &gt;(n, vector&lt;T&gt;(m, val)), r{n}, c{m}{}
    mat operator+(const mat&amp; another) const {
        mat&lt;T&gt; X(r, c);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; c; j++){
                X[i][j] = (*this)[i][j] + another[i][j];
            }
        }
        return X;
    }
    mat operator-(const mat&amp; another) const {
        mat&lt;T&gt; X(r,c);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; c; j++){
                X[i][j] = (*this)[i][j] - another[i][j];
            }
        }
        return X;
    }
    mat operator*(const mat&amp; another) const {
        mat&lt;T&gt; X(r, another.c);
        for(int i = 0; i &lt; r; i++){
            for(int k = 0; k &lt; c; k++){
                if(!(*this)[i][k]) continue;
                for(int j = 0; j &lt; (another.c); j++){
                    X[i][j] += (*this)[i][k] * another[k][j];
                }
            }
        }
        return X;
    }
    vector&lt;int&gt; rank(){
        mat&lt;T&gt; X(r, c);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; c; j++){
                X[i][j] = (*this)[i][j];
            }
        }
        vector&lt;int&gt; index;
        int res = 0;
        for(int i = 0; i &lt; c; i++){
            if(res == r) break;
            if(!X[res][i]){
                int pivot = res + 1;
                for(; pivot &lt; r; pivot++){
                    if(X[pivot][i]){
                        swap(X[res], X[pivot]);
                        break;
                    }
                }
                if(pivot == r) continue;
            }
            const T p = (T)1 / X[res][i];
            for(int j = i + 1; j &lt; c; j++){ X[res][j] *= p; }
            for(int j = res + 1; j &lt; r; j++){
                if(!X[j][i]) continue;
                for(int k = i + 1; k &lt; c; k++){
                    X[j][k] -= X[res][k] * X[j][i];
                }
            }
            index.push_back(i), ++res;
        }
        return index;
    }
    bool det_zero() const {
        mat&lt;T&gt; X(r);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; c; j++){
                X[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i &lt; c; i++){
            if(!X[i][i]){
                int pivot = i + 1;
                for(; pivot &lt; r; pivot++){
                    if(X[pivot][i]){
                        swap(X[i], X[pivot]);
                        break;
                    }
                }
                if(pivot == r) return true;
            }
            const T p = (T)1 / X[i][i];
            for(int j = i + 1; j &lt; c; j++){ X[i][j] *= p; }
            for(int j = i + 1; j &lt; r; j++){
                if(!X[j][i]) continue;
                for(int k = i + 1; k &lt; c; k++){
                    X[j][k] -= X[i][k] * X[j][i];
                }
            }
        }
        return false;
    }
    mat inverse() const {
        mat X(r, 2*r);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; r; j++){
                X[i][j] = (*this)[i][j];
            }
        }
        for(int i = 0; i &lt; r; i++){
            X[i][r+i] = 1;
        }
        for(int i = 0; i &lt; r; i++){
            if(!X[i][i]){
                int pivot = i + 1;
                for(; pivot &lt; r; pivot++){
                    if(X[pivot][i]){
                        swap(X[i],X[pivot]);
                        break;
                    }
                }
                assert(pivot &lt; r);
            }
            const T p = (T)1 / X[i][i];
            for(int j = i + 1; j &lt; 2*r; j++){ X[i][j] *= p; }
            for(int j = 0; j &lt; r; j++){
                if(i == j || !X[j][i]) continue;
                for(int k = i + 1; k &lt; 2*r; k++){
                    X[j][k] -= X[i][k] * X[j][i];
                }
            }
        }
        mat res(r, r);
        for(int i = 0; i &lt; r; i++){
            for(int j = 0; j &lt; r; j++){
                res[i][j] = X[i][r+j];
            }
        }
        return res;
    }
};

class Matching {
private:
    const int V;
    vector&lt;pair&lt;int, int&gt; &gt; es;
    vector&lt;int&gt; index, cnt;
    random_device rnd;
    mt19937 mt;
    uniform_int_distribution&lt;&gt; randval;
    static constexpr int LOOP = 1;
    static constexpr unsigned int mod = 1000000007;
    mat&lt;ModInt&lt;mod&gt; &gt; inverse_22(const int id, const mat&lt;ModInt&lt;mod&gt; &gt;&amp; invT){
        ModInt&lt;mod&gt; invdev = (ModInt&lt;mod&gt;)1 / (invT[0][0]*invT[id][id] - invT[0][id]*invT[id][0]);
        mat&lt;ModInt&lt;mod&gt; &gt; invN_3n_3n(2, 2);
        invN_3n_3n[0][0] = invT[id][id] * invdev, invN_3n_3n[0][1] = -invT[0][id] * invdev;
        invN_3n_3n[1][0] = -invT[id][0] * invdev, invN_3n_3n[1][1] = invT[0][0] * invdev;
        return invN_3n_3n;
    }
    void schur_complement(const int id, mat&lt;ModInt&lt;mod&gt; &gt;&amp; invT){
        int sz = invT.row(), x = 0;
        mat&lt;ModInt&lt;mod&gt; &gt;N_12_12(sz-2), N_12_3n(sz-2, 2), N_3n_12(2, sz-2);
        for(int i = 1; i &lt; sz; i++){
            if(i == id) continue;
            int y = 0;
            for(int j = 1; j &lt; sz; j++){
                if(j == id) continue;
                N_12_12[x][y] = invT[i][j];
                N_3n_12[0][y] = invT[0][j], N_3n_12[1][y++] = invT[id][j];
            }
            N_12_3n[x][0] = invT[i][0], N_12_3n[x++][1] = invT[i][id];
        }
        invT = N_12_12 - N_12_3n * inverse_22(id, invT) * N_3n_12;
    }
    void find_matching(const mat&lt;ModInt&lt;mod&gt; &gt;&amp; T){
        int sz = T.row();
        mat&lt;ModInt&lt;mod&gt; &gt; invT = T.inverse();
        vector&lt;int&gt; vset(sz); iota(vset.begin(), vset.end(), 0);
        for(int i = sz; i &gt; 0; i -= 2){
            for(int j = 1; j &lt; i; j++){
                if(invT[0][j] &amp;&amp; T[vset[0]][vset[j]]){
                    ans.emplace_back(index[vset[0]], index[vset[j]]);
                    vset.erase(vset.begin()), vset.erase(vset.begin() + j - 1);
                    schur_complement(j, invT);
                    break;
                }
            }
        }
    }

public:
    vector&lt;pair&lt;int, int&gt; &gt; ans;

    Matching(const int node_size)
        : V(node_size), cnt(V + 1, 0), mt(rnd()), randval(1, mod - 1){}
    void add_edge(const int u, const int v){ es.emplace_back(u, v); }
    bool perfect_matchching(){
        for(int i = 0; i &lt; LOOP; i++){
            mat&lt;ModInt&lt;mod&gt; &gt; A(V);
            for(auto e : es){
                int r = randval(mt);
                A[e.first][e.second] = r, A[e.second][e.first] = -r;
            }
            if(!A.det_zero()) return true;
        }
        return false;
    }
    int maximum_matchching(){
        for(int i = 0; i &lt; LOOP; i++){
            mat&lt;ModInt&lt;mod&gt; &gt; A(V);
            for(auto e : es){
                int r = randval(mt);
                A[e.first][e.second] = r, A[e.second][e.first] = -r;
            }
            vector&lt;int&gt; res = A.rank();
            ++cnt[res.size()];
            if((size_t)(max_element(cnt.begin(), cnt.end()) - cnt.begin()) == res.size()){
                index = move(res);
            }
        }
        return (int)(max_element(cnt.begin(), cnt.end()) - cnt.begin()) / 2;
    }
    int find_maximum_matching(){
        const int sz = maximum_matchching();
        vector&lt;pair&lt;int, int&gt; &gt; ans_tmp;
        vector&lt;int&gt; unzip(V, -1);
        for(int i = 0; i &lt; 2 * sz; ++i) unzip[index[i]] = i;
        for(int i = 0; i &lt; LOOP; i++){
            mat&lt;ModInt&lt;mod&gt; &gt; A(2 * sz);
            for(auto e : es){
                const int u = unzip[e.first], v = unzip[e.second];
                if(u &lt; 0 || v &lt; 0) continue;
                int r = randval(mt);
                A[u][v] = r, A[v][u] = -r;
            }
            if(!A.det_zero()){
                find_matching(A);
                break;
            }
        }
        return sz;
    }
};
</pre>
</div>
<h3>verify 用の問題</h3>
<p>
完全マッチングの判定の verify(実際には微妙に異なる)<br>
AOJ : <a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2347">Sunny Graph</a>
  <a href="http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3804014#1">提出コード</a><br>
最大マッチングの判定および構築の verify<br>
Atcoder : <a href="https://joisc2016matching.contest.atcoder.jp/tasks/joisc2016matching_a">一般最大マッチング</a>
  <a href="https://joisc2016matching.contest.atcoder.jp/submissions/8208685">提出コード</a><br>
yosupo さんの library checker : <a href="https://judge.yosupo.jp/problem/general_matching">Matching on General Graph</a>
  <a href="https://judge.yosupo.jp/submission/1211">提出コード</a>
</p>
</section>

</div>
<!--/contents-->

<footer>
<small>Copyright&copy; <a href="../../index.html"> My Algorithm : kopricky アルゴリズムライブラリ </a> All Rights Reserved.</small>
<span class="pr">《<a href="https://template-party.com/" target="_blank">Web Design:Template-Party</a>》</span>
</footer>

<script src="../../js/prettify.js"></script>
<script src="../../js/lang-css.js"></script>
<!-- prettyPrint()関数を実行するため追加↓ -->
<script>prettyPrint();</script>

</div>
<!--/container-->

</body>
</html>
