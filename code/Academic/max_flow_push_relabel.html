<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title> My Algorithm : kopricky アルゴリズムライブラリ </title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="競技プログラミングで使われるアルゴリズムのコード集">
<meta name="keywords" content="競技プログラミング,競プロ,アルゴリズム,コード,kopricky,computation,datastructure,geometry,graph,networkflow,string,icpc,Atcoder">
<link rel="stylesheet" href="../../css/style.css">
<script type="text/javascript" src="../../js/openclose.js"></script>
<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="../../css/prettify.css" type="text/css">
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>

<div id="container">

<header>
<h1 id="logo"><a href="../../index.html"><img src="../../images/logo.png" alt="kopricky アルゴリズムライブラリ"></a></h1>
</header>


<nav id="menubar">
<ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../guide.html">Guide</a></li>
<li class="current"><a href="../../code.html">Code</a></li>
<li><a href="../../link.html">Link</a></li>
</ul>
</nav>

<div id="contents">

<section>
<h2>Push Relabel</h2>
<h3>コードについての説明</h3>
<p>
フロー f が s, t 間の最大フローであるとは (1) (v から出る量) = (v に入る量) (∀ v ∈ V / {s,t}), (2) 残余ネットワークに augment path(増加道) が存在しない の 2 つが成り立つことが必要十分条件である. <br>
Edmonds-Karp, Dinic などは (1) の条件を常に満たしながら (2) の条件を成立させようとしていたのに対し, Push Relabel は (2) の条件を常に満たしながら (1) の条件を成立させようとするアルゴリズムになっている. <br>
よく言われるイメージは各頂点に (in flow - out flow) の量の水がタンクに入っており, また各頂点に高さが割り振られている(初期値は始点が n, それ以外は 0). このとき s, t 以外の頂点についてタンクに水が入っている(活性点と呼ぶ)ならそれを自分より高さの低い隣り合う頂点に min(水の量, 辺の容量) だけ流すという操作(Push 操作)を最終的に (1) の条件を満たすまで続ける. <br>
もし自分より高さの低い隣り合う頂点がない場合は自分の高さを min(隣り合う頂点の高さ) + 1 に更新する操作(Relabel 操作) を行う. ここで頂点 u の高さを p(u) としたとき, 辺 e = (u, v) について p(u) - p(v) <= 1 が成り立つことに注意する. ここで p(u) - p(v) < 1 の場合は f(e) = 0 もしくは e.cap が成り立ち, p(u) - p(v) = 1 の場合のみ 0 < f(e) < e.cap となりうる. これは相補性条件に対応する. <br>
ここで s から t にもしたどり着けるなら、パスに沿って不等式をあてはめると p(s) - p(t) <= n-1 が成り立つはずだが p(s) = n, p(t) = 0 より s から t には常にたどり着けないことが分かる. つまり (2) の条件は常に満たされる. よって (1) が満たされたとき, max flow が得られる.<br>
残りはこの操作が O(n^2 m^(1/2)) の計算量で終了することであるが <a href="https://www.amazon.co.jp/%E7%B5%84%E5%90%88%E3%81%9B%E6%9C%80%E9%81%A9%E5%8C%96-%E7%AC%AC2%E7%89%88-%E7%90%86%E8%AB%96%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0-B-%E3%82%B3%E3%83%AB%E3%83%86/dp/4621062026/ref=sr_1_2?ie=UTF8&qid=1536456416&sr=8-2&keywords=%E7%B5%84%E5%90%88%E3%81%9B%E6%9C%80%E9%81%A9%E5%8C%96%E3%81%A8%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0">組合せ最適化(Korte, Fiegen)</a> などを参考にしてください. 愚直にやると O(n^2 m) かかり, push 操作の順番を常に活性点の中から高さの １ 番高いものから始めるということをすると計算量が O(n^2 m^(1/2)) に落ちる(これが非自明). <br>
<strike>以下の実装では p(u) - p(v) = 1 かつ cap > 0 の辺を常に管理しているが</strike>(⇒ 追記(実装変更した)), 毎回 push 操作時に流せる辺を探索してもちゃんとやると計算量 O(n^2 m^(1/2)) が保証できる(⇒ 補足).<br>
元論文は <a href="http://akira.ruc.dk/~keld/teaching/algoritmedesign_f03/Artikler/08/Goldberg88.pdf">Goldberg and Tarjan 1988</a> で動的木を用いて計算量の改善が可能(元論文では活性点の中から高さの １ 番高いものから始めるという手法ではなく活性点を queue で管理して更新を行っているので計算量は O(n^3) となっている). <br>
<strike>計算量は O(n^2 m^(1/2)) なので Dinic(計算量 O(n^2m)) よりも優秀だが, 特に 2 部グラフのマッチングの場合とかについては以下の実装では速くないです. p(u) - p(v) = 1, cap > 0 の辺をリストで管理するより, global_relabel(ときどき全部を再ラベリング), gap_relabel(ある高さの活性点がなくなったらそれ以上の高さの活性点を再ラベリング) の 2 つのヒューリスティックを行った方が速いんだろうな. global_relabel はやったが gap_relabel の方は現在の実装では実装がめんどくさくなるのでやるならこの参考のようにやるとよさそう(<a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/94/1523/CS-TR-94-1523.pdf">参考</a>).</strike> (⇒ 追記)<br>
(補足) <br>
各頂点 v について今見ている辺の index をちゃんと持っておいて、 もし途中で saturating push を行って終了してまたそのあともう一度活性点となった場合は続きの index から始めるとすると良い. v の隣接リストを 1 周したら必ず Relabel 操作が呼ばれ, この Relabel 操作は各頂点で高々 O(n) 回なので探索の for 文なめるのは全体で O(nm) 回になる.<br>
<strike>以下の実装は組み合わせ最適化本に沿って実装したけど、こうした方が以下の実装より絶対に楽だし, 計算量もちゃんと O(n^2 m^(1/2)) なので時間があれば変更したい</strike> <br>
(追記) <br>
<a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/94/1523/CS-TR-94-1523.pdf">(参考)</a> をもとに実装を変更した. 上記の gap_relabel および global_relabel を行った実装にしたことで高速になり, 多くのケースでは <a href="../NetworkFlow/dinic.html">Dinic</a> より速くなった. <a href="https://min-25.hatenablog.com/entry/2017/08/22/211034">この記事</a> が頂点の管理を自作リストで行っていて, 確かに高速化できそうだったので採用させていただいた(ただ全体の実装にはいくつか計算量的な意味での誤りが見られた). <br>
</p>
<p>
(関数)<br>
add_edge(from, to, cap): 容量 cap の辺 (from, to) を追加する <br>
solve(s, t): s, t 間の最大フローを計算する
</p>
<p>
時間計算量: O(n^2 m^(1/2))
</p>
<h3>コード</h3>
<div class="codebox">
<input type="checkbox" id="label" class="csscode" />
<label for="label"></label>]
<pre class="prettyprint linenums">
class Stack {
private:
    const int N, H;
    vector&lt;int&gt; node;
public:
    Stack(const int _N, const int _H) : N(_N), H(_H), node(N+H){ clear(); }
    inline bool empty(const int h){ return node[N+h] == N+h; }
    inline int top(const int h){ return node[N+h]; }
    inline void pop(const int h){ node[N+h] = node[node[N+h]]; }
    inline void push(const int h, const int u){ node[u] = node[N+h], node[N+h] = u; }
    inline void clear(){ iota(node.begin() + N, node.end(), N); }
};

class List
{
public:
    struct node {
        int prev, next;
    };
    const int N, H;
    vector&lt;size_t&gt; sz;
    vector&lt;node&gt; dat;
    List(const int _N, const int _H) : N(_N), H(_H), sz(H, 0), dat(N+H){ clear(); }
    inline size_t size(const int h) const { return sz[h]; }
    inline bool empty(const int h) const { return (sz[h] == 0); }
    inline void insert(const int h, const int u){
        ++sz[h];
        dat[u].prev = dat[N+h].prev, dat[u].next = N+h;
        dat[dat[N+h].prev].next = u, dat[N+h].prev = u;
    }
    inline void erase(const int h, const int u){
        --sz[h];
        dat[dat[u].prev].next = dat[u].next, dat[dat[u].next].prev = dat[u].prev;
    }
    inline void clear(){
        for(int i = N; i &lt; N+H; ++i) dat[i].prev = dat[i].next = i;
    }
};

template &lt;typename T&gt; class PushRelabel
{
public:
    struct edge {
        int to, rev;
        T cap;
        edge(int _to, int _rev, T _cap) : to(_to), rev(_rev), cap(_cap){}
    };
private:
    const int V;
    int s, t, pot_max, checker;
    vector&lt;T&gt; excess;
    vector&lt;int&gt; potential, cur_edge, que;
    List all_ver;
    Stack act_ver;
    int calc_active(){
        pot_max = -1;
        for(int i = 0; i &lt; V; ++i){
            if(potential[i] &lt; V){
                cur_edge[i] = 0;
                pot_max = max(potential[i], pot_max);
                all_ver.insert(potential[i], i);
                if(excess[i] &gt; 0 &amp;&amp; i != t) act_ver.push(potential[i], i);
            }else{
                potential[i] = V+1;
            }
        }
        return pot_max;
    }
    void bfs(){
        for(int i = 0; i &lt; V; ++i) potential[i] = max(potential[i], V);
        potential[t] = 0;
        int qh = 0, qt = 0;
        for(que[qt++] = t; qh++ &lt; qt;){
            int u = que[qh-1];
            for(edge&amp; e : G[u]){
                if(potential[e.to] == V &amp;&amp; G[e.to][e.rev].cap &gt; 0){
                    potential[e.to] = potential[u] + 1, que[qt++] = e.to;
                }
            }
        }
    }
    int init(){
        potential[s] = V+1;
        bfs();
        for(edge&amp; e : G[s]){
            if(potential[e.to] &lt; V){
                G[e.to][e.rev].cap = e.cap, excess[s] -= e.cap, excess[e.to] += e.cap;
            }
            e.cap = 0;
        }
        return calc_active();
    }
    int global_relabel(){
        bfs();
        all_ver.clear(), act_ver.clear();
        return calc_active();
    }
    void gap_relabel(const int u){
        for(int i = potential[u]; i &lt;= pot_max; ++i){
            for(int id = all_ver.dat[V+i].next; id &lt; V; id = all_ver.dat[id].next){
                potential[id] = V+1;
            }
            all_ver.sz[i] = 0;
            all_ver.dat[V+i].prev = all_ver.dat[V+i].next = V+i;
        }
    }
    int discharge(const int u){
        for(int&amp; i = cur_edge[u]; i &lt; (int)G[u].size(); ++i){
            edge&amp; e = G[u][i];
            if(potential[u] == potential[e.to] + 1 &amp;&amp; e.cap &gt; 0){
                if(push(u, e)) return potential[u];
            }
        }
        return relabel(u);
    }
    bool push(const int u, edge&amp; e){
        T f = min(e.cap, excess[u]);
        const int v = e.to;
        e.cap -= f, excess[u] -= f;
        G[v][e.rev].cap += f, excess[v] += f;
        if(excess[v] == f &amp;&amp; v != t) act_ver.push(potential[v], v);
        return (excess[u] == 0);
    }
    int relabel(const int u){
        ++checker;
        int prv = potential[u], cur = V;
        for(int i = 0; i &lt; (int)G[u].size(); ++i){
            edge&amp; e = G[u][i];
            if(cur &gt; potential[e.to] + 1 &amp;&amp; e.cap &gt; 0){
                cur_edge[u] = i;
                cur = potential[e.to] + 1;
            }
        }
        if((int)all_ver.size(prv) &gt; 1){
            all_ver.erase(prv, u);
            if((potential[u] = cur) == V) return potential[u] = V+1, prv;
            act_ver.push(cur, u);
            all_ver.insert(cur, u);
            pot_max = max(pot_max, cur);
        }else{
            gap_relabel(u);
            return pot_max = prv - 1;
        }
        return cur;
    }
public:
    vector&lt;vector&lt;edge&gt; &gt; G;
    PushRelabel(const int node_size)
        : V(node_size), pot_max(-1), checker(0), excess(V, (T)0),
            potential(V, 0), cur_edge(V), que(V), all_ver(V, V), act_ver(V, V), G(V){}
    void add_edge(const int _from, const int _to, const T _cap){
        G[_from].emplace_back(_to, (int)G[_to].size(), _cap);
        G[_to].emplace_back(_from, (int)G[_from].size() - 1, 0);
    }
    T solve(const int source, const int sink){
        s = source, t = sink;
        int level = init();
        while(level &gt;= 0){
            if(act_ver.empty(level)){
                --level;
                continue;
            }
            int u = act_ver.top(level);
            act_ver.pop(level);
            if(excess[u] == 0) continue;
            level = discharge(u);
            if(checker &gt;= V / 2){
                level = global_relabel();
                checker = 0;
            }
        }
        return excess[t];
    }
};
</pre>
<h3>verify 用の問題</h3>
<p>AOJ : <a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A">Maximum Flow</a>
  <a href="http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3768548#1">提出コード</a></p>
</section>

</div>
<!--/contents-->

<footer>
<small>Copyright&copy; <a href="../../index.html"> My Algorithm : kopricky アルゴリズムライブラリ </a> All Rights Reserved.</small>
<span class="pr">《<a href="https://template-party.com/" target="_blank">Web Design:Template-Party</a>》</span>
</footer>

<script src="../../js/prettify.js"></script>
<script src="../../js/lang-css.js"></script>
<!-- prettyPrint()関数を実行するため追加↓ -->
<script>prettyPrint();</script>

</div>
<!--/container-->

</body>
</html>
