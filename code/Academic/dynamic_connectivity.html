<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131511873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131511873-1');
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
$\newcommand{\O}{\mathrm{O}}$

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title> My Algorithm : kopricky アルゴリズムライブラリ </title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="競技プログラミングで使われるアルゴリズムのコード集">
<meta name="keywords" content="競技プログラミング,競プロ,アルゴリズム,コード,kopricky,computation,datastructure,geometry,graph,networkflow,string,icpc,Atcoder">
<link rel="stylesheet" href="../../css/style.css">
<script type="text/javascript" src="../../js/openclose.js"></script>
<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="../../css/prettify.css" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>

<div id="container">

<header>
<h1 id="logo"><a href="../../index.html"><img src="../../images/logo.png" alt="kopricky アルゴリズムライブラリ"></a></h1>
</header>


<nav id="menubar">
<ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../guide.html">Guide</a></li>
<li class="current"><a href="../../code.html">Code</a></li>
<li><a href="../../link.html">Link</a></li>
</ul>
</nav>

<div id="contents">

<section>
<h2>Dynamic Connectivity Algorithm</h2>
<h3>コードについての説明</h3>
<p>
一般のグラフを対象に辺の追加, 削除, 頂点間の連結性判定を効率よく行うことのできるアルゴリズム. <a href="../DataStructure_OnGraph/link_cut_tree.html">Link Cut Tree</a>, <a href="../DataStructure_OnGraph/euler_tour_tree.html">Euler Tour Tree</a> などは森を対象にしていたためそれの一般化にあたる.<br>
元論文は "Poly-logarithmic deterministic fully-dynamic algorithms for connectivity, minimum spannning tree, 2-edge, and biconnectivity" [Holm, Lichtenberg, Thorup 1998]<br>
グラフ $G$ の全域森を管理する. このとき $\log n$ 個の Euler Tour Tree を用いて Scaling(Layering) することで辺を削除した際の restore 操作の高速化を(ならしの意味で)可能にしている.
具体的には各辺がレベル $l(e)$ ($0 \le l(e) \le \log n$) を持っていて, 最初は全て $0$ である. レベル $i$ 以上の辺からなるグラフを $G_i$ としたとき,
EulerTourTree で $G_i$ の全域森 $F_i$ を保持する. このとき $F_i$ について次の 2 つの条件が常に成り立つ.
(i) $F_i$ 内の木(連結成分)の最大サイズは $\lfloor n / 2^i \rfloor$ 以下である.
(ii) $F_0 ⊇ F_1 ... ⊇ F_{\log n}$ を満たす. <br>
$F_i$ に含まれない $G_i$ 内の辺 $e$ (off tree edge) については辺の端点に対応する EulerTourTree のノードに "off tree edge がある" という情報を格納して,
例えば $F_i$ 内の辺が cut され新たに連結成分が増えてしまうという場合に off tree edge の中から非連結となった頂点集合どうしを再び連結させるような辺がないかを探索する(restore 操作) ときに参照される.
このときに効率よく探索する必要があり, そのために Euler Tour Tree の各ノードに "そのノードを根とする部分木内に off tree edge があるか" などの情報を平衡二分探索木上で適切に遅延伝播させたりなどする.<br>
平衡二分探索木上で辺をたどる操作 1 回につき "ある辺のレベルが $1$ 増える" or "処理が終了する" のどちらかが成り立つため, 全体の計算量はよく抑えられる(ポテンシャルとしては例えば $\sum_{e \in E} \log n (\log n - l(e))$ などを考えると良い).<br>
確実に何を言っているかわからないと思うので詳しく知りたい方は元論文を参照してもらいたい.<br>
Euler Tour Tree 上で情報を正しく伝播させる必要があるため実装は割と気をつける必要がある. 計算量は辺の追加, 削除がならし $\O (\log^2 n)$, 連結性判定が $\O (\log n)$ である. Euler Tour Tree を平衡二分木ではなく $\O (\log n)$-分木で管理することで計算量上は $\O (\log \log n)$ factor の改善が可能になる. <br>
restore 操作を辺の重みが小さいものから順に走査することで $F_0$ が常に最小全域森となるように保つことができる.
これから deletion-only の場合削除クエリに対してならし $\O (\log^2 n)$ の計算量で動的なグラフの最小全域森を管理できることも言える. insertion 込みだとコストの小さい辺が入ってきたときにコストの小さい辺は削除時の探索順の関係で level の高い位置に置く必要があるが, そうするとならしが回らないので無理そうである.
ただ deletion-only を fully dynamic にするテクを用いると fully dynamic の場合に各クエリならし $\O (\log^4 n)$ の計算量で動的なグラフの最小全域森を管理することができる.
実際に最小全域森を出力しようとすると最悪 $\Omega (n)$ time かかるので, 設定としては最新のグラフの最小全域森が以前のものと変化する場合にその差分を上記計算量で出力することができれば最小全域森を管理することができると考える.<br>
ちなみに最小全域森の online Fully Dynamic アルゴリズムについてはクエリにかかる最悪計算量は長年 $\O (\sqrt{n})$ であることが知られていて, 最近になって進展があり $\O (n^{\mathrm{o(1)}})$ の計算量で管理できるアルゴリズムが発表された(FOCS 2017). ちゃんと読んでいないが dynamic expander pruning が本質っぽい（？). dynamic expander pruning について SODA 2019 の "Expander Decomposition and Pruning:
Faster, Stronger, and Simpler" を先にまず読んだ方が良さそうなので読む.(⇒ 読んで理解した.)<br>
一般グラフの動的連結性クエリに答えるデータ構造も同じ感じで最悪計算量を $\O (\sqrt{n})$ から $\O (n^{\mathrm{o(1)}})$ にしようという気運が高まっている. <br>
連結性判定だけでなく連結成分内の頂点全体への演算も $F_0$ に対する操作で簡単に行えるので計算量は $\O (\log n)$. 連結成分内の辺全体への演算は $F_0$ において全ての level の off tree edge を保持しておくようにすればこちらも計算量 $\O (\log n)$ で行える(はず). <br>
以下の実装では平衡二分木として splay 木を用いている. 少し高速化を行っているため restore 操作時の処理がわかりにくいと思われる(本当に変更を伝播する必要のあるときのみ伝播するみたいなことをしている). グラフは単純グラフであることを仮定している(多重辺, 自己ループがあっても外部で適切に処理すれば問題ない). <br>
<br>
(補足) <br>
"Lower Bounds for Dynamic Connectivity" [Patrascu, Demaine 2004] により動的連結性の operation の lower bound が amortized でも randomized でも $\Omega(\log n)$ time となることが示された(これは update もしくは query の少なくとも一方が $\Omega(\log n)$ time の意味).
また更新時間(link, cut) とクエリに応答する時間(connected) の間に存在する trade-off 関係も示している.
具体的に update time を $t_u$, query time を $t_q$ とすると <img src="./texclip20190808090008.png" height="100" width="350"> という関係が成り立つ. また trade-off の lower bound をオーダーの意味で達成するアルゴリズムとして [Thorup 2000] や [Holm, Lichtenberg, Thorup 2001] がある. <br>
worst input の構成などのより詳しい内容は論文もしくは <a href="https://courses.csail.mit.edu/6.851/fall17/scribe/L21.pdf">Demaine 先生の講義</a> が参考になると思うが, 少々とっつきにくかったので暇があれば解説記事などをちゃんと書きたい. (暇があれば...) <br>
ちなみに worst case はパスの集合で構成できるため森の動的連結性クエリの lower bound も $\Omega (\log n)$ であることが言え, Link Cut Tree や Euler Tour Tree は漸近的に最適であることが分かる. <br>
<br>
(補足 2) <br>
上記の Thorup のアルゴリズムはクエリを処理するのに最悪 $\Theta(n)$ の計算量がかかってしまう.
最悪計算量をよく抑えるアルゴリズムとしては各クエリについて最悪 $\widetilde{\mathrm{O}} (m^{1/2})$ 時間を保証するアルゴリズムが "Data structures for on-line updating of minimum spanning trees" [Frederickson 1984] で提案されている.
このアルゴリズムはグラフの全域木を管理しながら動的連結クエリに答えるアルゴリズムで、少し改良することで動的最小全域森問題の最悪計算量についても同じオーダーを保証することができる.
大まかな流れは (i) 一般グラフの動的連結性問題は計算量のオーダーを悪くすることなく各頂点の次数が 3 以下であるグラフの動的連結性問題に帰着できる.
(ii) そのようなグラフの全域木にはある辺 $e$ についてその辺を削除したときにできる 2 つの木のそれぞれの頂点数がある程度同じ大きさとなるというようなもの(edge separator) が存在する.
(iii) クラスターの頂点数が $\sqrt{m}$ になるまで上記の分割を再帰的に繰り返し, 各クラスターでは対応する頂点集合上の全域森を保持する. またクラスター間にある辺も別で保持しておく
(iv) insert, delete クエリを上記の構造を保つように更新する. delete クエリの方が本質で愚直にやると少し時間がかかるが, Euler Tour Tree(元論文では Topology Tree) を用いることで非連結となった全域木を修復するような辺を効率よく見つけることが可能になり, 上記のオーダーを達成できる.
<br>
この手法は "Sparsification–A Technique for Speeding Up Dynamic Graph Algorithms" [Eppstein, Galil, Italiano, Nissenzweig 1997] で sparsification technique というものを用いて $\widetilde{O} (n^{1/2})$ に改善された.
大まかな流れは (i) 辺集合 $E (m = |E|)$ を $E_1, ..., E_K$ の $K = \lceil m / n \rceil$ 個の辺集合に分けて管理する. 各辺集合のサイズは $n$ である(最後の $E_K$ だけは $n$ 個以下).
(ii) 各辺集合からなるグラフ $G_i = (V, E_i)$ を平衡二分木の葉ノードに対応させる. いま左の子のグラフを $G_1 = (V, E_1)$, その全域森を $F_1$, 右の子のグラフを $G_2 = (V, E_2)$, その全域森を $F_2$ とする. このとき親ノードのグラフを
$G = (V, E_1 \cup E_2)$ とすると, グラフ $G$ の連結性はグラフ $F_1 \cup F_2$ の連結性に等しいことが言える. つまり任意の異なる 2 頂点について $G$ 上で連結であるかどうかは $F_1 \cup F_2$ 上で連結であるかどうかと同値であることが言える.
アルゴリズムでは各ノードでそのノードに対応するグラフの全域森を管理するのだが, 上記の議論から親ノードのグラフ($G$) の全域森は子ノードの全域森の和集合($F_1 \cup F_2$) の全域森と考えて良いことになる.
(iii) ここで各ノードについて全域森を動的に管理する部分に [Frederickson 1984] のアルゴリズムを black box 的に用いる. 各ノードについてこの black box にクエリとして与えられる辺は 2 つの子ノードの全域森 $F_1$, $F_2$ 内の辺であり, $F_1 \cup F_2$ の全域森を管理する.
いま辺数のサイズが $\O (n)$ であるので各ノードで全域森を管理するにあたって 1 回のクエリは最悪 $\widetilde{O} (n^{1/2})$ 時間で行えることに注意する.
平衡二分木は葉ノードの数が $\lceil m / n \rceil$ 個なので深さは $\log \lceil m / n \rceil$ である. 加えて全体のグラフに対する 1 回の insert, delete クエリは 1
つの葉ノードおよびその先祖にしか影響を及ぼさないこと, 変更する必要のある辺の数は insert の場合は 1 つ, delete の場合は高々 2 つであることが示せるので結局各クエリについて最悪
$\widetilde{O} (n^{1/2})$ 時間を達成することが可能になる. <br>
<br>
(追記 1) <br>
高速な自作 <a href="../OriginalContainer/unordered_map.html">Unordered Map</a>, <a href="../OriginalContainer/unordered_set.html">Unordered Set</a> を用いた高速版も一応用意した. <br>
ただ unordered_map, unordered_set 自体がそこまでボトルネックになっていないので速度はあまり速くならない. あとコードが長くなるので前者のほうがおすすめ. <br>
</p>
<p>
(関数)<br>
link$(a, b)$ : 辺$(a, b)$ を追加(連結成分が減るかどうか(true / false) を返す) <br>
cut$(a, b)$ : 辺$(a, b)$ を削除(連結成分が増えるかどうか(true / false) を返す) <br>
connected$(a, b)$ : 頂点 $a$, $b$ が同じ連結成分内に属するかどうかを判定する(true / false)
</p>
<p>
時間計算量: link, cut ならし $\O (\log^2 n)$, connected $\O (\log n)$
</p>
<h3>コード</h3>
<div class="codebox">
<input type="checkbox" id="label" class="csscode" />
<label for="label"></label>
<pre class="prettyprint linenums">
class BSTNode {
public:
    const int from, to;
    int sz;
    bool subtree_edge, subofftree_edge, exact_level;
    BSTNode *left, *right, *par;
    unordered_set&lt;int&gt; adjacent;
    BSTNode(const int _ver) noexcept :
        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),
            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}
    BSTNode(const int _from, const int _to, const bool _flag) noexcept :
        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),
            exact_level((from &lt; to) &amp;&amp; _flag), left(nullptr), right(nullptr), par(nullptr){}
    inline bool IsRoot() const noexcept { return !par; }
    inline bool IsVertex() const noexcept { return (from == to); }
    inline void eval() noexcept {
        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();
        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;
        if(left){
            sz += left-&gt;sz, subtree_edge |= left-&gt;subtree_edge, subofftree_edge |= left-&gt;subofftree_edge;
        }
        if(right){
            sz += right-&gt;sz, subtree_edge |= right-&gt;subtree_edge, subofftree_edge |= right-&gt;subofftree_edge;
        }
    }
    inline void subtree_edge_eval(){
        subtree_edge = exact_level;
        if(left) subtree_edge |= left-&gt;subtree_edge;
        if(right) subtree_edge |= right-&gt;subtree_edge;
    }
    inline void subofftree_edge_eval(){
        subofftree_edge = !adjacent.empty();
        if(left) subofftree_edge |= left-&gt;subofftree_edge;
        if(right) subofftree_edge |= right-&gt;subofftree_edge;
    }
    inline bool subofftree_check(){
        return !adjacent.empty() ||
                (left ? left-&gt;subofftree_edge : false) || (right ? right-&gt;subofftree_edge : false);
    }
    inline bool offtree_check(){
        return adjacent.empty() ||
                (left ? left-&gt;subofftree_edge : false) || (right ? right-&gt;subofftree_edge : false);
    }
    void rotate(const bool right_) noexcept {
        BSTNode *p = par, *g = p-&gt;par;
        if(right_){
            if((p-&gt;left = right)) right-&gt;par = p;
            right = p, p-&gt;par = this;
        }else{
            if((p-&gt;right = left)) left-&gt;par = p;
            left = p, p-&gt;par = this;
        }
        p-&gt;eval(), eval();
        if(!(par = g)) return;
        if(g-&gt;left == p) g-&gt;left = this;
        if(g-&gt;right == p) g-&gt;right = this;
        g-&gt;eval();
    }
};

BSTNode *splay(BSTNode *u) noexcept {
    if(!u) return nullptr;
    while(!(u-&gt;IsRoot())){
        BSTNode *p = u-&gt;par, *gp = p-&gt;par;
        if(p-&gt;IsRoot()){ // zig
            u-&gt;rotate((u == p-&gt;left));
        }else{
            bool flag = (u == p-&gt;left);
            if((u == p-&gt;left) == (p == gp-&gt;left)){ // zig-zig
                p-&gt;rotate(flag), u-&gt;rotate(flag);
            }else{ // zig-zag
                u-&gt;rotate(flag), u-&gt;rotate(!flag);
            }
        }
    }
    return u;
}

BSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {
    if(!root1 || !root2) return root1 ? root1 : root2;
    BSTNode *cur = nullptr, *nx = root1;
    do{ cur = nx, nx = cur-&gt;right; }while(nx);
    BSTNode *ver = splay(cur);
    ver-&gt;right = root2, ver-&gt;eval(), root2-&gt;par = ver;
    return ver;
}

class EulerTourTree {
public:
    struct pair_hash {
        template &lt;class T1, class T2&gt;
        size_t operator() (const pair&lt;T1, T2&gt;&amp; p) const {
            size_t lhs = hash&lt;T1&gt;()(p.first), rhs = hash&lt;T2&gt;()(p.second);
            return lhs^(rhs+0x9e3779b9+(lhs&lt;&lt;6)+(lhs&gt;&gt;2));
        }
    };
    BSTNode** vertex_set;
    unordered_map&lt;pair&lt;int, int&gt;, pair&lt;BSTNode*, BSTNode*&gt;, pair_hash&gt; edge_set;
private:
    BSTNode *reroot(BSTNode *ver) noexcept {
        BSTNode *res = splay(ver)-&gt;left;
        if(!res) return ver;
        ver-&gt;left = nullptr, ver-&gt;eval();
        while(ver-&gt;right) ver = ver-&gt;right;
        splay(ver), ver-&gt;right = res, ver-&gt;eval(), res-&gt;par = ver;
        return ver;
    }
    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {
        BSTNode *e1 = new BSTNode(ver1-&gt;from, ver2-&gt;from, flag);
        BSTNode *e2 = new BSTNode(ver2-&gt;from, ver1-&gt;from, flag);
        edge_set[{ver1-&gt;from, ver2-&gt;from}] = {e1, e2};
        join(join(reroot(ver1), e1), join(reroot(ver2), e2));
    }
    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {
        splay(edge1), splay(edge2);
        BSTNode *p = edge1-&gt;par;
        bool _right = (edge1 == edge2-&gt;right);
        if(p != edge2){
            _right = (p == edge2-&gt;right);
            p-&gt;par = nullptr, edge1-&gt;rotate((edge1 == p-&gt;left));
        }
        if(edge1-&gt;left) edge1-&gt;left-&gt;par = nullptr;
        if(edge1-&gt;right) edge1-&gt;right-&gt;par = nullptr;
        if(_right){
            if(edge2-&gt;left) edge2-&gt;left-&gt;par = nullptr;
            join(edge2-&gt;left, edge1-&gt;right);
        }else{
            if(edge2-&gt;right) edge2-&gt;right-&gt;par = nullptr;
            join(edge1-&gt;left, edge2-&gt;right);
        }
        // delete edge1; delete edge2;
    }
    bool IsConnected(BSTNode *ver1, BSTNode *ver2) noexcept {
        splay(ver1), splay(ver2);
        return ver1-&gt;par;
    }
    int component_size(BSTNode *ver) noexcept { return splay(ver)-&gt;sz; }
public:
    int V;
    EulerTourTree(){}
    // ~EulerTourTree(){
    //     for(auto it : edge_set){
    //         delete (it.second).first;
    //         delete (it.second).second;
    //     }
    //     for(int i = 0; i &lt; V; ++i) delete vertex_set[i];
    //     delete[] vertex_set;
    // }
    void resize(const int node_size) noexcept {
        V = node_size, vertex_set = new BSTNode*[V];
        for(int i = 0; i &lt; V; i++) vertex_set[i] = new BSTNode(i);
    }
    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }
    void link(int node1_id, int node2_id, bool flag=true) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        link(vertex_set[node1_id], vertex_set[node2_id], flag);
    }
    void cut(int node1_id, int node2_id){
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        auto it = edge_set.find({node1_id, node2_id});
        assert(it != edge_set.end());
        BSTNode *edge1 = (it-&gt;second).first, *edge2 = (it-&gt;second).second;
        edge_set.erase(it);
        cut(edge1, edge2);
    }
    bool IsConnected(const int node1_id, const int node2_id) noexcept {
        if(node1_id == node2_id) return true;
        return IsConnected(vertex_set[node1_id], vertex_set[node2_id]);
    }
    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }
    void check_dfs(const BSTNode* cur) const noexcept {
        if(cur-&gt;left) check_dfs(cur-&gt;left);
        cout &lt;&lt; &quot;{&quot; &lt;&lt; (cur-&gt;from) &lt;&lt; &quot;,&quot; &lt;&lt; (cur-&gt;to) &lt;&lt; &quot;} &quot;;
        if(cur-&gt;right) check_dfs(cur-&gt;right);
    }
};

class DynamicConnectivity {
private:
    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {
        if(cur-&gt;exact_level){
            splay(cur)-&gt;exact_level = false, cur-&gt;subtree_edge_eval();
            detect_layer[{cur-&gt;from, cur-&gt;to}]++, et[layer+1].link(cur-&gt;from, cur-&gt;to);
            return cur;
        }
        if(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;subtree_edge) return level_up_dfs(cur-&gt;left, layer);
        if(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;subtree_edge) return level_up_dfs(cur-&gt;right, layer);
        return nullptr;
    }
    BSTNode *search_edge_dfs
        (BSTNode *cur, const int layer, const int another, bool&amp; flag, pair&lt;int, int&gt;&amp; rep_edge) noexcept {
        if(!cur-&gt;adjacent.empty()){
            bool state = et[layer+1].vertex_set[cur-&gt;from]-&gt;adjacent.empty();
            for(auto it = cur-&gt;adjacent.begin(); it != cur-&gt;adjacent.end();){
                pair&lt;int, int&gt; e = {min(cur-&gt;from, *it), max(cur-&gt;from, *it)};
                BSTNode *correspond = et[layer].vertex_set[*it];
                if(et[layer].IsConnected(another, *it)){
                    flag = true, rep_edge = e;
                    cur-&gt;adjacent.erase(it), correspond-&gt;adjacent.erase(cur-&gt;from);
                    if(!correspond-&gt;subofftree_check()){
                        splay(correspond)-&gt;subofftree_edge_eval();
                    }
                    break;
                }else{
                    if(!et[layer+1].vertex_set[*it]-&gt;subofftree_check()){
                        splay(et[layer+1].vertex_set[*it])-&gt;subofftree_edge = true;
                    }
                    et[layer+1].vertex_set[cur-&gt;from]-&gt;adjacent.insert(*it);
                    et[layer+1].vertex_set[*it]-&gt;adjacent.insert(cur-&gt;from);
                    detect_layer[e]++, it = cur-&gt;adjacent.erase(it);
                    correspond-&gt;adjacent.erase(cur-&gt;from);
                    if(!correspond-&gt;subofftree_check()){
                        splay(correspond)-&gt;subofftree_edge_eval();
                    }
                }
            }
            if(state &amp;&amp; !et[layer+1].vertex_set[cur-&gt;from]-&gt;offtree_check()){
                splay(et[layer+1].vertex_set[cur-&gt;from])-&gt;subofftree_edge = true;
            }
            splay(cur)-&gt;subofftree_edge_eval();
            return cur;
        }
        if(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;subofftree_edge){
            return search_edge_dfs(cur-&gt;left, layer, another, flag, rep_edge);
        }
        if(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;subofftree_edge){
            return search_edge_dfs(cur-&gt;right, layer, another, flag, rep_edge);
        }
        return nullptr;
    }
    bool replace(const int from, const int to, const int layer) noexcept {
        if(layer &lt; 0) return true;
        int u, v;
        if(et[layer].component_size(from) &lt;= et[layer].component_size(to)) u = from, v = to;
        else u = to, v = from;
        BSTNode *ver = splay(et[layer].vertex_set[u]);
        while(ver-&gt;subtree_edge) ver = level_up_dfs(ver, layer);
        pair&lt;int, int&gt; rep_edge = {-1, -1};
        bool flag = false;
        while(ver-&gt;subofftree_edge){
            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);
            if(flag) break;
        }
        if(flag){
            et[layer].link(rep_edge.first, rep_edge.second);
            for(int i = 0; i &lt; layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);
            return false;
        }else return replace(from, to, layer-1);
    }
public:
    const int V, layer_count;
    EulerTourTree* et;
    unordered_map&lt;pair&lt;int, int&gt;, int, EulerTourTree::pair_hash&gt; detect_layer;
    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){
        et = new EulerTourTree[layer_count];
        for(int i = 0; i &lt; layer_count; i++) et[i].resize(V);
    }
    // ~DynamicConnectivity(){
    //     delete[] et;
    // }
    bool link(int node1_id, int node2_id) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        detect_layer[{node1_id, node2_id}] = 0;
        if(et[0].IsConnected(node1_id, node2_id)){
            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];
            splay(ver1)-&gt;subofftree_edge = true, ver1-&gt;adjacent.insert(node2_id);
            splay(ver2)-&gt;subofftree_edge = true, ver2-&gt;adjacent.insert(node1_id);
            return false;
        }else{
            et[0].link(node1_id, node2_id);
            return true;
        }
    }
    bool cut(int node1_id, int node2_id) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        auto it = detect_layer.find({node1_id, node2_id});
        assert(it != detect_layer.end());
        int layer = it-&gt;second;
        detect_layer.erase(it);
        auto&amp; st = et[layer].vertex_set[node1_id]-&gt;adjacent;
        if(st.find(node2_id) == st.end()){
            for(int i = 0; i &lt;= layer; i++) et[i].cut(node1_id, node2_id);
            return replace(node1_id, node2_id, layer);
        }else{
            et[layer].vertex_set[node1_id]-&gt;adjacent.erase(node2_id);
            if(!et[layer].vertex_set[node1_id]-&gt;subofftree_check()){
                splay(et[layer].vertex_set[node1_id])-&gt;subofftree_edge_eval();
            }
            et[layer].vertex_set[node2_id]-&gt;adjacent.erase(node1_id);
            if(!et[layer].vertex_set[node2_id]-&gt;subofftree_check()){
                splay(et[layer].vertex_set[node2_id])-&gt;subofftree_edge_eval();
            }
            return false;
        }
    }
    bool IsConnected(const int node1_id, const int node2_id) noexcept {
        return et[0].IsConnected(node1_id, node2_id);
    }
};
</pre>
<h3>コード(高速版)</h3>
<input type="checkbox" id="label2" class="csscode" />
<label for="label2"></label>
<pre class="prettyprint linenums">
// 高速ではあるが自作 unordered_set, unordered_map が少し不安なので通常版(こちらもかなり高速)の方がいいかも
template&lt;class _Key, class _Hash, bool DOWNSIZE&gt; class UnorderedSetIterator;

template&lt;class _Key, class _Hash = hash&lt;_Key&gt;, bool DOWNSIZE = false&gt;
class UnorderedSet
{
private:
    using iterator = UnorderedSetIterator&lt;_Key, _Hash, DOWNSIZE&gt;;
    friend UnorderedSetIterator&lt;_Key, _Hash, DOWNSIZE&gt;;
    struct bucket {
        _Key _key;
        short int _dist;
        bool _last, _end;
        bucket() noexcept : _dist(-1), _last(false), _end(false){}
        bucket&amp; operator=(const bucket&amp; another) = default;
        ~bucket(){ if(!empty()) _key.~_Key(); }
        inline void clear() noexcept { _dist = -1; }
        inline void _delete(){ _dist = -1, _key.~_Key(); }
        inline bool empty() const noexcept { return (_dist == -1); }
    };
    inline static unsigned int ceilpow2(unsigned int u) noexcept {
        --u, u |= u &gt;&gt; 1, u |= u &gt;&gt; 2, u |= u &gt;&gt; 4, u |= u &gt;&gt; 8;
        return (u | (u &gt;&gt; 16)) + 1;
    }
    inline static bucket *increment(bucket *cur) noexcept {
        for(++cur; !cur-&gt;_end; ++cur){
            if(!cur-&gt;empty()) break;
        }
        return cur;
    }
    inline bucket *next_bucket(bucket *cur) const noexcept {
        return cur-&gt;_last ? _buckets : cur + 1;
    }
    inline unsigned int make_hash(const _Key&amp; key) const noexcept {
        return _Hash()(key);
    }
    inline float load_rate() const noexcept {
        return (float)_data_count / _bucket_count;
    }
    bucket *insert(bucket *cur, short int dist, _Key&amp;&amp; key){
        bucket *ret = cur;
        bool flag = false;
        while(true){
            if(cur-&gt;empty()){
                cur-&gt;_key = move(key), cur-&gt;_dist = dist;
                if(!flag) ret = cur, flag = true;
                break;
            }else if(dist &gt; cur-&gt;_dist){
                swap(key, cur-&gt;_key), swap(dist, cur-&gt;_dist);
                if(!flag) ret = cur, flag = true;
            }
            ++dist;
            cur = next_bucket(cur);
        }
        return ret;
    }
    bucket *_find(const _Key&amp; key) const {
        bucket *cur = _buckets + (make_hash(key) &amp; _mask);
        int dist = 0;
        while(dist &lt;= cur-&gt;_dist){
            if(key == cur-&gt;_key) return cur;
            ++dist, cur = next_bucket(cur);
        }
        return _buckets + _bucket_count;
    }
    template&lt;class Key&gt;
    bucket *find_insert(Key&amp;&amp; key){
        unsigned int hash = make_hash(key);
        bucket *cur = _buckets + (hash &amp; _mask);
        int dist = 0;
        while(dist &lt;= cur-&gt;_dist){
            if(key == cur-&gt;_key) return cur;
            ++dist, cur = next_bucket(cur);
        }
        ++_data_count;
        if(rehash_check()){
            cur = _buckets + (hash &amp; _mask), dist = 0;
        }
        _Key new_key = forward&lt;Key&gt;(key);
        return insert(cur, dist, move(new_key));
    }
    bucket *backward_shift(bucket *cur, bool next_ret){
        bucket *next = next_bucket(cur), *ret = cur;
        if(next-&gt;_dist &lt; 1) return next_ret ? increment(cur) : cur;
        do {
            cur-&gt;_key = next-&gt;_key, cur-&gt;_dist = next-&gt;_dist - 1;
            cur = next, next = next_bucket(cur);
        }while(next-&gt;_dist &gt;= 1);
        cur-&gt;clear();
        return ret;
    }
    bucket *erase_impl(bucket *cur, bool next_ret){
        assert(static_cast&lt;size_t&gt;(cur - _buckets) != _bucket_count);
        cur-&gt;_delete();
        --_data_count;
        return backward_shift(cur, next_ret);
    }
    bucket *erase_itr(bucket *cur, bool next_ret = true){
        const _Key key = cur-&gt;_key;
        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);
    }
    bucket *erase_key(const _Key&amp; key, bool next_ret = true){
        rehash_check();
        return erase_impl(_find(key), next_ret);
    }
    bool rehash_check(){
        if(load_rate() &gt;= MAX_LOAD_RATE){
            rehash(_bucket_count * 2u);
            return true;
        }else if(DOWNSIZE){
            if(load_rate() &lt;= MIN_LOAD_RATE &amp;&amp; _bucket_count &gt;= DOWNSIZE_THRESHOLD){
                rehash(_bucket_count / 2u);
                return true;
            }
        }
        return false;
    }
    void move_data(bucket *cur){
        insert(_buckets + (make_hash(cur-&gt;_key) &amp; _mask), 0, move(cur-&gt;_key));
    }
    void rehash(unsigned int new_bucket_count){
        UnorderedSet new_unordered_set(new_bucket_count);
        new_unordered_set._data_count = _data_count;
        for(bucket *cur = _buckets; !cur-&gt;_end; ++cur){
            if(!cur-&gt;empty()){
                new_unordered_set.move_data(cur);
            }
        }
        swap(*this, new_unordered_set);
    }
    friend void swap(UnorderedSet&amp; ust1, UnorderedSet&amp; ust2){
        swap(ust1._bucket_count, ust2._bucket_count);
        swap(ust1._mask, ust2._mask);
        swap(ust1._data_count, ust2._data_count);
        swap(ust1._buckets, ust2._buckets);
    }

private:
    unsigned int _bucket_count, _mask, _data_count;
    bucket *_buckets;
public:
    const float MAX_LOAD_RATE = 0.5f;
    const float MIN_LOAD_RATE = 0.1f;
    const unsigned int DOWNSIZE_THRESHOLD = 16u;
    UnorderedSet(unsigned int bucket_size = 1u)
     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),
        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){
        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;
    }
    UnorderedSet(const UnorderedSet&amp; another)
        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){
        _buckets = new bucket[_bucket_count + 1u];
        for(unsigned int i = 0u; i &lt;= _bucket_count; ++i){
            _buckets[i] = another._buckets[i];
        }
    }
    UnorderedSet(UnorderedSet&amp;&amp; another)
        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),
            _data_count(move(another._data_count)), _buckets(another._buckets){
        another._buckets = nullptr;
    }
    UnorderedSet&amp; operator=(const UnorderedSet&amp; another){
        delete[] _buckets;
        _bucket_count = another._bucket_count;
        _mask = another._mask;
        _data_count = another._data_count;
        _buckets = new bucket[_bucket_count + 1u];
        for(unsigned int i = 0u; i &lt;= _bucket_count; ++i){
            _buckets[i] = another._buckets[i];
        }
        return *this;
    }
    UnorderedSet&amp; operator=(UnorderedSet&amp;&amp; another){
        delete[] _buckets;
        _bucket_count = move(another._bucket_count);
        _mask = move(another._mask);
        _data_count = move(another._data_count);
        _buckets = another._buckets;
        another._buckets = nullptr;
        return *this;
    }
    ~UnorderedSet(){ delete[] _buckets; }
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, UnorderedSet&amp; ust) noexcept {
        for(_Key&amp; val : ust) os &lt;&lt; val &lt;&lt; &quot; &quot;;
        return os;
    }
    void clear(){
        UnorderedSet new_unordered_set(1u);
        swap(*this, new_unordered_set);
    }
    size_t size() const noexcept { return _data_count; }
    size_t bucket_count() const noexcept { return _bucket_count; }
    bool empty() const noexcept { return (_data_count == 0); }
    iterator begin() const noexcept {
        return _buckets-&gt;empty() ? iterator(increment(_buckets)) : iterator(_buckets);
    }
    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }
    iterator find(const _Key&amp; key) const { return iterator(_find(key)); }
    size_t count(const _Key&amp; key) const { return (_find(key) != _buckets + _bucket_count); }
    iterator insert(const _Key&amp; key){ return iterator(find_insert(key)); }
    iterator insert(_Key&amp;&amp; key){ return iterator(find_insert(move(key))); }
    iterator erase(const _Key&amp; key){ return iterator(erase_key(key)); }
    iterator erase(const iterator&amp; itr){ return iterator(erase_itr(itr.bucket_ptr)); }
    void simple_erase(const _Key&amp; key){ erase_key(key, false); }
    void simple_erase(const iterator&amp; itr){ erase_itr(itr.bucket_ptr, false); }

    // DEBUG 用
    short int maximum_distance() const noexcept {
        short int ret = -1;
        for(bucket *cur = _buckets; !cur-&gt;_end; ++cur){
            ret = max(ret, cur-&gt;_dist);
        }
        return ret;
    }
};

template&lt;class _Key, class _Hash, bool DOWNSIZE&gt;
class UnorderedSetIterator {
private:
    friend UnorderedSet&lt;_Key, _Hash, DOWNSIZE&gt;;
    typename UnorderedSet&lt;_Key, _Hash, DOWNSIZE&gt;::bucket *bucket_ptr;
    using iterator_category = forward_iterator_tag;
    using value_type = _Key;
    using difference_type = ptrdiff_t;
    using pointer = _Key*;
    using reference = _Key&amp;;

private:
    UnorderedSetIterator(typename UnorderedSet&lt;_Key, _Hash, DOWNSIZE&gt;::bucket *_bucket_ptr)
        noexcept : bucket_ptr(_bucket_ptr){}
public:
    UnorderedSetIterator() noexcept : bucket_ptr(){}
    UnorderedSetIterator(const UnorderedSetIterator&amp; itr) noexcept : bucket_ptr(itr.bucket_ptr){}
    UnorderedSetIterator&amp; operator=(const UnorderedSetIterator&amp; itr)
        &amp; noexcept { return bucket_ptr = itr.bucket_ptr, *this; }
    UnorderedSetIterator&amp; operator=(const UnorderedSetIterator&amp;&amp; itr)
        &amp; noexcept { return bucket_ptr = itr.bucket_ptr, *this; }
    reference operator*() const noexcept { return bucket_ptr-&gt;_key; }
    pointer operator-&gt;() const noexcept { return &amp;(bucket_ptr-&gt;_key); }
    UnorderedSetIterator&amp; operator++() noexcept {
        return bucket_ptr = UnorderedSet&lt;_Key, _Hash, DOWNSIZE&gt;::increment(bucket_ptr), *this;
    }
    UnorderedSetIterator operator++(int) const noexcept {
        return UnorderedSetIterator(UnorderedSet&lt;_Key, _Hash, DOWNSIZE&gt;::increment(this-&gt;bucket_ptr));
    }
    bool operator==(const UnorderedSetIterator&amp; itr) const noexcept { return !(*this != itr); };
    bool operator!=(const UnorderedSetIterator&amp; itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }
};

template&lt;class _Key, class _Tp, class _Hash, bool DOWNSIZE&gt; class UnorderedMapIterator;

template&lt;class _Key, class _Tp, class _Hash = hash&lt;_Key&gt;, bool DOWNSIZE = false&gt;
class UnorderedMap
{
private:
    using iterator = UnorderedMapIterator&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;;
    using value_type = _Tp;
    using data_type = pair&lt;_Key, _Tp&gt;;
    using aligned_pointer = typename aligned_storage&lt;sizeof(value_type), alignof(value_type)&gt;::type;
    friend UnorderedMapIterator&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;;
    struct bucket {
        _Key _key;
        short int _dist;
        bool _last, _end;
        aligned_pointer _value_ptr;
        bucket() noexcept : _dist(-1), _last(false), _end(false){}
        bucket&amp; operator=(const bucket&amp; another) noexcept {
            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;
            if(!another.empty()){
                new(&amp;_value_ptr) value_type(*reinterpret_cast&lt;const value_type*&gt;(&amp;another._value_ptr));
            }
            return *this;
        }
        ~bucket(){ if(!empty()) _delete(); }
        inline void clear() noexcept { _dist = -1; }
        inline void _delete(){ _dist = -1, value_ptr()-&gt;~value_type(); }
        inline bool empty() const noexcept { return (_dist == -1); }
        inline value_type&amp; value() noexcept {
            return *reinterpret_cast&lt;value_type*&gt;(&amp;_value_ptr);
        }
        inline value_type* value_ptr() noexcept {
            return reinterpret_cast&lt;value_type*&gt;(&amp;_value_ptr);
        }
        inline void new_value(value_type&amp;&amp; value){
            new(&amp;_value_ptr) value_type(move(value));
        }
    };
    inline static unsigned int ceilpow2(unsigned int u) noexcept {
        --u, u |= u &gt;&gt; 1, u |= u &gt;&gt; 2, u |= u &gt;&gt; 4, u |= u &gt;&gt; 8;
        return (u | (u &gt;&gt; 16)) + 1;
    }
    inline static bucket *increment(bucket *cur) noexcept {
        for(++cur; !cur-&gt;_end; ++cur){
            if(!cur-&gt;empty()) break;
        }
        return cur;
    }
    inline bucket *next_bucket(bucket *cur) const noexcept {
        return cur-&gt;_last ? _buckets : cur + 1;
    }
    inline unsigned int make_hash(const _Key&amp; key) const noexcept {
        return _Hash()(key);
    }
    inline float load_rate() const noexcept {
        return (float)_data_count / _bucket_count;
    }
    bucket *insert(bucket *cur, _Key&amp;&amp; key, short int dist, value_type&amp;&amp; value){
        bucket *ret = cur;
        bool flag = false;
        while(true){
            if(cur-&gt;empty()){
                cur-&gt;_key = move(key), cur-&gt;_dist = dist, cur-&gt;new_value(move(value));
                if(!flag) ret = cur, flag = true;
                break;
            }else if(dist &gt; cur-&gt;_dist){
                swap(key, cur-&gt;_key), swap(dist, cur-&gt;_dist), swap(value, cur-&gt;value());
                if(!flag) ret = cur, flag = true;
            }
            ++dist;
            cur = next_bucket(cur);
        }
        return ret;
    }
    template&lt;class Key&gt;
    bucket *_find(Key&amp;&amp; key, bool push = false){
        unsigned int hash = make_hash(key);
        bucket *cur = _buckets + (hash &amp; _mask);
        short int dist = 0;
        while(dist &lt;= cur-&gt;_dist){
            if(key == cur-&gt;_key) return cur;
            ++dist, cur = next_bucket(cur);
        }
        if(!push) return _buckets + _bucket_count;
        ++_data_count;
        if(rehash_check()){
            cur = _buckets + (hash &amp; _mask), dist = 0;
        }
        value_type new_value = value_type();
        _Key new_key = forward&lt;Key&gt;(key);
        return insert(cur, move(new_key), dist, move(new_value));
    }
    template&lt;class Data&gt;
    bucket *find_insert(Data&amp;&amp; data){
        const _Key&amp; key = data.first;
        unsigned int hash = make_hash(key);
        bucket *cur = _buckets + (hash &amp; _mask);
        short int dist = 0;
        while(dist &lt;= cur-&gt;_dist){
            if(key == cur-&gt;_key) return cur;
            ++dist, cur = next_bucket(cur);
        }
        ++_data_count;
        if(rehash_check()){
            cur = _buckets + (hash &amp; _mask), dist = 0;
        }
        data_type new_data = forward&lt;Data&gt;(data);
        return insert(cur, move(new_data.first), dist, move(new_data.second));
    }
    bucket *backward_shift(bucket *cur, bool next_ret){
        bucket *next = next_bucket(cur), *ret = cur;
        if(next-&gt;_dist &lt; 1) return next_ret ? increment(cur) : cur;
        do {
            cur-&gt;_key = next-&gt;_key, cur-&gt;_dist = next-&gt;_dist - 1;
            cur-&gt;new_value(move(next-&gt;value()));
            cur = next, next = next_bucket(cur);
        }while(next-&gt;_dist &gt;= 1);
        cur-&gt;clear();
        return ret;
    }
    bucket *erase_impl(bucket *cur, bool next_ret){
        assert(static_cast&lt;size_t&gt;(cur - _buckets) != _bucket_count);
        cur-&gt;_delete();
        --_data_count;
        return backward_shift(cur, next_ret);
    }
    bucket *erase_itr(bucket *cur, bool next_ret = true){
        const _Key&amp; key = cur-&gt;_key;
        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);
    }
    bucket *erase_key(const _Key&amp; key, bool next_ret = true){
        rehash_check();
        return erase_impl(_find(key), next_ret);
    }
    bool rehash_check(){
        if(load_rate() &gt;= MAX_LOAD_RATE){
            rehash(_bucket_count * 2u);
            return true;
        }else if(DOWNSIZE){
            if(load_rate() &lt;= MIN_LOAD_RATE &amp;&amp; _bucket_count &gt;= DOWNSIZE_THRESHOLD){
                rehash(_bucket_count / 2u);
                return true;
            }
        }
        return false;
    }
    void move_data(bucket *cur){
        insert(_buckets + (make_hash(cur-&gt;_key) &amp; _mask), move(cur-&gt;_key), 0, move(cur-&gt;value()));
    }
    void rehash(unsigned int new_bucket_count){
        UnorderedMap new_unordered_map(new_bucket_count);
        new_unordered_map._data_count = _data_count;
        for(bucket *cur = _buckets; !cur-&gt;_end; ++cur){
            if(!cur-&gt;empty()){
                new_unordered_map.move_data(cur);
            }
        }
        swap(*this, new_unordered_map);
    }
    friend void swap(UnorderedMap&amp; ump1, UnorderedMap&amp; ump2){
        swap(ump1._bucket_count, ump2._bucket_count);
        swap(ump1._mask, ump2._mask);
        swap(ump1._data_count, ump2._data_count);
        swap(ump1._buckets, ump2._buckets);
    }

private:
    unsigned int _bucket_count, _mask, _data_count;
    bucket *_buckets;
public:
    const float MAX_LOAD_RATE = 0.5f;
    const float MIN_LOAD_RATE = 0.1f;
    const unsigned int DOWNSIZE_THRESHOLD = 16u;
    UnorderedMap(unsigned int bucket_size = 1u)
     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),
        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){
        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;
    }
    UnorderedMap(const UnorderedMap&amp; another)
        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){
        _buckets = new bucket[_bucket_count + 1u];
        for(unsigned int i = 0u; i &lt;= _bucket_count; ++i){
            _buckets[i] = another._buckets[i];
        }
    }
    UnorderedMap(UnorderedMap&amp;&amp; another)
        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),
            _data_count(move(another._data_count)), _buckets(another._buckets){
        another._buckets = nullptr;
    }
    UnorderedMap&amp; operator=(const UnorderedMap&amp; another){
        delete[] _buckets;
        _bucket_count = another._bucket_count;
        _mask = another._mask;
        _data_count = another._data_count;
        _buckets = new bucket[_bucket_count + 1u];
        for(unsigned int i = 0u; i &lt;= _bucket_count; ++i){
            _buckets[i] = another._buckets[i];
        }
        return *this;
    }
    UnorderedMap&amp; operator=(UnorderedMap&amp;&amp; another){
        delete[] _buckets;
        _bucket_count = move(another._bucket_count);
        _mask = move(another._mask);
        _data_count = move(another._data_count);
        _buckets = another._buckets;
        another._buckets = nullptr;
        return *this;
    }
    ~UnorderedMap(){ delete[] _buckets; }
    friend ostream&amp; operator&lt;&lt; (ostream&amp; os, UnorderedMap&amp; ump) noexcept {
        for(auto val : ump) os &lt;&lt; '{' &lt;&lt; val.first &lt;&lt; ',' &lt;&lt; val.second &lt;&lt; &quot;} &quot;;
        return os;
    }
    _Tp&amp; operator[](const _Key&amp; key){ return _find(key, true)-&gt;value(); }
    _Tp&amp; operator[](_Key&amp;&amp; key){ return _find(move(key), true)-&gt;value(); }
    const _Tp&amp; at(const _Key&amp; key){
        bucket *res = _find(key);
        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(&quot;Unordered_Map::at&quot;));
        return res-&gt;value();
    }
    void clear(){
        UnorderedMap new_unordered_map(1u);
        swap(*this, new_unordered_map);
    }
    size_t size() const noexcept { return _data_count; }
    size_t bucket_count() const noexcept { return _bucket_count; }
    bool empty() const noexcept { return (_data_count == 0); }
    iterator begin() const noexcept { return _buckets-&gt;empty() ? iterator(increment(_buckets)) : iterator(_buckets); }
    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }
    iterator find(const _Key&amp; key){ return iterator(_find(key)); }
    iterator insert(const data_type&amp; data){ return iterator(find_insert(data)); }
    iterator insert(data_type&amp;&amp; data){ return iterator(find_insert(move(data))); }
    iterator erase(const _Key&amp; key){ return iterator(erase_key(key)); }
    iterator erase(const iterator&amp; itr){ return iterator(erase_itr(itr.bucket_ptr)); }
    void simple_erase(const _Key&amp; key){ erase_key(key, false); }
    void simple_erase(const iterator&amp; itr){ erase_itr(itr.bucket_ptr, false); }

    // DEBUG 用
    short int maximum_distance() const noexcept {
        short int ret = -1;
        for(bucket *cur = _buckets; !cur-&gt;_end; ++cur){
            ret = max(ret, cur-&gt;_dist);
        }
        return ret;
    }
};

template&lt;class _Key, class _Tp, class _Hash, bool DOWNSIZE&gt;
class UnorderedMapIterator {
private:
    friend UnorderedMap&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;;
    typename UnorderedMap&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;::bucket *bucket_ptr;
    using iterator_category = forward_iterator_tag;
    using value_type = pair&lt;const _Key, _Tp&gt;;
    using difference_type = ptrdiff_t;
    using reference = pair&lt;const _Key&amp;, _Tp&amp;&gt;;

private:
    UnorderedMapIterator(typename UnorderedMap&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;::bucket *_bucket_ptr)
        noexcept : bucket_ptr(_bucket_ptr){}
public:
    UnorderedMapIterator() noexcept : bucket_ptr(){}
    UnorderedMapIterator(const UnorderedMapIterator&amp; itr) noexcept : bucket_ptr(itr.bucket_ptr){}
    UnorderedMapIterator&amp; operator=(const UnorderedMapIterator&amp; itr)
        &amp; noexcept { return bucket_ptr = itr.bucket_ptr, *this; }
    UnorderedMapIterator&amp; operator=(const UnorderedMapIterator&amp;&amp; itr)
        &amp; noexcept { return bucket_ptr = itr.bucket_ptr, *this; }
    reference operator*() const noexcept { return {bucket_ptr-&gt;_key, bucket_ptr-&gt;value()}; }
    UnorderedMapIterator&amp; operator++() noexcept {
        return bucket_ptr = UnorderedMap&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;::increment(bucket_ptr), *this;
    }
    UnorderedMapIterator operator++(int) const noexcept {
        return UnorderedMapIterator(UnorderedMap&lt;_Key, _Tp, _Hash, DOWNSIZE&gt;::increment(this-&gt;bucket_ptr));
    }
    bool operator==(const UnorderedMapIterator&amp; itr) const noexcept { return !(*this != itr); };
    bool operator!=(const UnorderedMapIterator&amp; itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }
};

// 多重辺は無いと仮定する
class BSTNode {
public:
    struct murmur_hash32 {
        unsigned int operator()(int p) const {
            const unsigned int m = 0x5bd1e995; p *= m;
            unsigned int h = (p^(p&gt;&gt;24))*m;
            return h = (h^(h&gt;&gt;13))*m, (h^(h&gt;&gt;15));
        }
    };
    const int from, to;
    int sz;
    bool subtree_edge, subofftree_edge, exact_level;
    BSTNode *left, *right, *par;
    UnorderedSet&lt;int, murmur_hash32, true&gt; adjacent;
    BSTNode(const int _ver) noexcept :
        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),
            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}
    BSTNode(const int _from, const int _to, const bool _flag) noexcept :
        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),
            exact_level((from &lt; to) &amp;&amp; _flag), left(nullptr), right(nullptr), par(nullptr){}
    inline bool IsRoot() const noexcept { return !par; }
    inline bool IsVertex() const noexcept { return (from == to); }
    inline void eval() noexcept {
        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();
        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;
        if(left){
            sz += left-&gt;sz, subtree_edge |= left-&gt;subtree_edge, subofftree_edge |= left-&gt;subofftree_edge;
        }
        if(right){
            sz += right-&gt;sz, subtree_edge |= right-&gt;subtree_edge, subofftree_edge |= right-&gt;subofftree_edge;
        }
    }
    inline void subtree_edge_eval(){
        subtree_edge = exact_level;
        if(left) subtree_edge |= left-&gt;subtree_edge;
        if(right) subtree_edge |= right-&gt;subtree_edge;
    }
    inline void subofftree_edge_eval(){
        subofftree_edge = !adjacent.empty();
        if(left) subofftree_edge |= left-&gt;subofftree_edge;
        if(right) subofftree_edge |= right-&gt;subofftree_edge;
    }
    inline bool subofftree_check(){
        return !adjacent.empty() ||
                (left ? left-&gt;subofftree_edge : false) || (right ? right-&gt;subofftree_edge : false);
    }
    inline bool offtree_check(){
        return adjacent.empty() ||
                (left ? left-&gt;subofftree_edge : false) || (right ? right-&gt;subofftree_edge : false);
    }
    void rotate(const bool right_) noexcept {
        BSTNode *p = par, *g = p-&gt;par;
        if(right_){
            if((p-&gt;left = right)) right-&gt;par = p;
            right = p, p-&gt;par = this;
        }else{
            if((p-&gt;right = left)) left-&gt;par = p;
            left = p, p-&gt;par = this;
        }
        p-&gt;eval(), eval();
        if(!(par = g)) return;
        if(g-&gt;left == p) g-&gt;left = this;
        if(g-&gt;right == p) g-&gt;right = this;
        g-&gt;eval();
    }
};

BSTNode *splay(BSTNode *u) noexcept {
    if(!u) return nullptr;
    while(!(u-&gt;IsRoot())){
        BSTNode *p = u-&gt;par, *gp = p-&gt;par;
        if(p-&gt;IsRoot()){ // zig
            u-&gt;rotate((u == p-&gt;left));
        }else{
            bool flag = (u == p-&gt;left);
            if((u == p-&gt;left) == (p == gp-&gt;left)){ // zig-zig
                p-&gt;rotate(flag), u-&gt;rotate(flag);
            }else{ // zig-zag
                u-&gt;rotate(flag), u-&gt;rotate(!flag);
            }
        }
    }
    return u;
}

BSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {
    if(!root1 || !root2) return root1 ? root1 : root2;
    BSTNode *cur = nullptr, *nx = root1;
    do{ cur = nx, nx = cur-&gt;right; }while(nx);
    BSTNode *ver = splay(cur);
    ver-&gt;right = root2, ver-&gt;eval(), root2-&gt;par = ver;
    return ver;
}

class EulerTourTree {
public:
    struct murmur_hash64 {
        unsigned long long operator()(unsigned long long p) const {
            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;
            unsigned long long h = (p^(p&gt;&gt;47))*m;
            return h = (h^(h&gt;&gt;47))*m, (h^(h&gt;&gt;47));
        }
    };
    inline static unsigned long long pair_to_ll(const int u, const int v){
        return ((unsigned long long)(u) &lt;&lt; 32) | v;
    }
    BSTNode** vertex_set;
    UnorderedMap&lt;unsigned long long, pair&lt;BSTNode*, BSTNode*&gt;, murmur_hash64&gt; edge_set;
private:
    BSTNode *reroot(BSTNode *ver) noexcept {
        BSTNode *res = splay(ver)-&gt;left;
        if(!res) return ver;
        ver-&gt;left = nullptr, ver-&gt;eval();
        while(ver-&gt;right) ver = ver-&gt;right;
        splay(ver), ver-&gt;right = res, ver-&gt;eval(), res-&gt;par = ver;
        return ver;
    }
    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {
        BSTNode *e1 = new BSTNode(ver1-&gt;from, ver2-&gt;from, flag);
        BSTNode *e2 = new BSTNode(ver2-&gt;from, ver1-&gt;from, flag);
        edge_set[pair_to_ll(ver1-&gt;from, ver2-&gt;from)] = {e1, e2};
        join(join(reroot(ver1), e1), join(reroot(ver2), e2));
    }
    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {
        splay(edge1), splay(edge2);
        BSTNode *p = edge1-&gt;par;
        bool _right = (edge1 == edge2-&gt;right);
        if(p != edge2){
            _right = (p == edge2-&gt;right);
            p-&gt;par = nullptr, edge1-&gt;rotate((edge1 == p-&gt;left));
        }
        if(edge1-&gt;left) edge1-&gt;left-&gt;par = nullptr;
        if(edge1-&gt;right) edge1-&gt;right-&gt;par = nullptr;
        if(_right){
            if(edge2-&gt;left) edge2-&gt;left-&gt;par = nullptr;
            join(edge2-&gt;left, edge1-&gt;right);
        }else{
            if(edge2-&gt;right) edge2-&gt;right-&gt;par = nullptr;
            join(edge1-&gt;left, edge2-&gt;right);
        }
        // delete edge1; delete edge2;
    }
    bool IsConnected(BSTNode *ver1, BSTNode *ver2) noexcept {
        splay(ver1), splay(ver2);
        return ver1-&gt;par;
    }
    int component_size(BSTNode *ver) noexcept { return splay(ver)-&gt;sz; }
public:
    int V;
    EulerTourTree(){}
    // ~EulerTourTree(){
    //     for(auto it : edge_set){
    //         delete (it.second).first;
    //         delete (it.second).second;
    //     }
    //     for(int i = 0; i &lt; V; ++i) delete vertex_set[i];
    //     delete[] vertex_set;
    // }
    void resize(const int node_size) noexcept {
        V = node_size, vertex_set = new BSTNode*[V];
        for(int i = 0; i &lt; V; i++) vertex_set[i] = new BSTNode(i);
    }
    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }
    void link(int node1_id, int node2_id, bool flag=true) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        link(vertex_set[node1_id], vertex_set[node2_id], flag);
    }
    void cut(int node1_id, int node2_id){
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));
        assert(it != edge_set.end());
        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;
        edge_set.simple_erase(it);
        cut(edge1, edge2);
    }
    bool IsConnected(const int node1_id, const int node2_id) noexcept {
        if(node1_id == node2_id) return true;
        return IsConnected(vertex_set[node1_id], vertex_set[node2_id]);
    }
    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }
    void check_dfs(const BSTNode* cur) const noexcept {
        if(cur-&gt;left) check_dfs(cur-&gt;left);
        cout &lt;&lt; &quot;{&quot; &lt;&lt; (cur-&gt;from) &lt;&lt; &quot;,&quot; &lt;&lt; (cur-&gt;to) &lt;&lt; &quot;} &quot;;
        if(cur-&gt;right) check_dfs(cur-&gt;right);
    }
};

class DynamicConnectivity {
private:
    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {
        if(cur-&gt;exact_level){
            splay(cur)-&gt;exact_level = false, cur-&gt;subtree_edge_eval();
            detect_layer[EulerTourTree::pair_to_ll(cur-&gt;from, cur-&gt;to)]++;
            et[layer+1].link(cur-&gt;from, cur-&gt;to);
            return cur;
        }
        if(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;subtree_edge) return level_up_dfs(cur-&gt;left, layer);
        if(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;subtree_edge) return level_up_dfs(cur-&gt;right, layer);
        return nullptr;
    }
    BSTNode *search_edge_dfs
        (BSTNode *cur, const int layer, const int another, bool&amp; flag, pair&lt;int, int&gt;&amp; rep_edge) noexcept {
        if(!cur-&gt;adjacent.empty()){
            bool state = et[layer+1].vertex_set[cur-&gt;from]-&gt;adjacent.empty();
            for(auto it = cur-&gt;adjacent.begin(); it != cur-&gt;adjacent.end();){
                pair&lt;int, int&gt; e = {min(cur-&gt;from, *it), max(cur-&gt;from, *it)};
                BSTNode *correspond = et[layer].vertex_set[*it];
                if(et[layer].IsConnected(another, *it)){
                    flag = true, rep_edge = e;
                    cur-&gt;adjacent.simple_erase(it), correspond-&gt;adjacent.simple_erase(cur-&gt;from);
                    if(!correspond-&gt;subofftree_check()){
                        splay(correspond)-&gt;subofftree_edge_eval();
                    }
                    break;
                }else{
                    if(!et[layer+1].vertex_set[*it]-&gt;subofftree_check()){
                        splay(et[layer+1].vertex_set[*it])-&gt;subofftree_edge = true;
                    }
                    et[layer+1].vertex_set[cur-&gt;from]-&gt;adjacent.insert(*it);
                    et[layer+1].vertex_set[*it]-&gt;adjacent.insert(cur-&gt;from);
                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;
                    it = cur-&gt;adjacent.erase(it);
                    correspond-&gt;adjacent.simple_erase(cur-&gt;from);
                    if(!correspond-&gt;subofftree_check()){
                        splay(correspond)-&gt;subofftree_edge_eval();
                    }
                }
            }
            if(state &amp;&amp; !et[layer+1].vertex_set[cur-&gt;from]-&gt;offtree_check()){
                splay(et[layer+1].vertex_set[cur-&gt;from])-&gt;subofftree_edge = true;
            }
            splay(cur)-&gt;subofftree_edge_eval();
            return cur;
        }
        if(cur-&gt;left &amp;&amp; cur-&gt;left-&gt;subofftree_edge){
            return search_edge_dfs(cur-&gt;left, layer, another, flag, rep_edge);
        }
        if(cur-&gt;right &amp;&amp; cur-&gt;right-&gt;subofftree_edge){
            return search_edge_dfs(cur-&gt;right, layer, another, flag, rep_edge);
        }
        return nullptr;
    }
    bool replace(const int from, const int to, const int layer) noexcept {
        if(layer &lt; 0) return true;
        int u, v;
        if(et[layer].component_size(from) &lt;= et[layer].component_size(to)) u = from, v = to;
        else u = to, v = from;
        BSTNode *ver = splay(et[layer].vertex_set[u]);
        while(ver-&gt;subtree_edge) ver = level_up_dfs(ver, layer);
        pair&lt;int, int&gt; rep_edge = {-1, -1};
        bool flag = false;
        while(ver-&gt;subofftree_edge){
            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);
            if(flag) break;
        }
        if(flag){
            et[layer].link(rep_edge.first, rep_edge.second);
            for(int i = 0; i &lt; layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);
            return false;
        }else return replace(from, to, layer-1);
    }
public:
    const int V, layer_count;
    EulerTourTree* et;
    UnorderedMap&lt;unsigned long long, int, EulerTourTree::murmur_hash64&gt; detect_layer;
    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){
        et = new EulerTourTree[layer_count];
        for(int i = 0; i &lt; layer_count; i++) et[i].resize(V);
    }
    // ~DynamicConnectivity(){
    //     delete[] et;
    // }
    bool link(int node1_id, int node2_id) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;
        if(et[0].IsConnected(node1_id, node2_id)){
            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];
            splay(ver1)-&gt;subofftree_edge = true, ver1-&gt;adjacent.insert(node2_id);
            splay(ver2)-&gt;subofftree_edge = true, ver2-&gt;adjacent.insert(node1_id);
            return false;
        }else{
            et[0].link(node1_id, node2_id);
            return true;
        }
    }
    bool cut(int node1_id, int node2_id) noexcept {
        if(node1_id &gt; node2_id) swap(node1_id, node2_id);
        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));
        assert(it != detect_layer.end());
        int layer = (*it).second;
        detect_layer.simple_erase(it);
        auto&amp; st = et[layer].vertex_set[node1_id]-&gt;adjacent;
        if(st.find(node2_id) == st.end()){
            for(int i = 0; i &lt;= layer; i++) et[i].cut(node1_id, node2_id);
            return replace(node1_id, node2_id, layer);
        }else{
            et[layer].vertex_set[node1_id]-&gt;adjacent.simple_erase(node2_id);
            if(!et[layer].vertex_set[node1_id]-&gt;subofftree_check()){
                splay(et[layer].vertex_set[node1_id])-&gt;subofftree_edge_eval();
            }
            et[layer].vertex_set[node2_id]-&gt;adjacent.simple_erase(node1_id);
            if(!et[layer].vertex_set[node2_id]-&gt;subofftree_check()){
                splay(et[layer].vertex_set[node2_id])-&gt;subofftree_edge_eval();
            }
            return false;
        }
    }
    bool IsConnected(const int node1_id, const int node2_id) noexcept {
        return et[0].IsConnected(node1_id, node2_id);
    }
};
</pre>
</div>
<h3>verify 用の問題</h3>
<p>AOJ : <a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2235&lang=jp">Graph Construction</a>
  <a href="http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3813963#1">提出コード</a><br>
(同じ問題で高速版の方は提出コード長制限に引っかかってしまいましたがテストケースをスクレイピングしてきて正答することを確認しました.)
</p>
</section>

</div>
<!--/contents-->

<footer>
<small>Copyright&copy; <a href="../../index.html"> My Algorithm : kopricky アルゴリズムライブラリ </a> All Rights Reserved.</small>
<span class="pr">《<a href="https://template-party.com/" target="_blank">Web Design:Template-Party</a>》</span>
</footer>

<script src="../../js/prettify.js"></script>
<script src="../../js/lang-css.js"></script>
<!-- prettyPrint()関数を実行するため追加↓ -->
<script>prettyPrint();</script>

</div>
<!--/container-->

</body>
</html>
