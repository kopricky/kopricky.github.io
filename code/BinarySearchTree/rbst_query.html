<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131511873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131511873-1');
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<meta http-equiv="X-UA-Compatible" CONTENT="IE=EmulateIE7" />
$\newcommand{\O}{\mathrm{O}}$

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title> My Algorithm : kopricky アルゴリズムライブラリ </title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="競技プログラミングで使われるアルゴリズムのコード集">
<meta name="keywords" content="競技プログラミング,競プロ,アルゴリズム,コード,kopricky,computation,datastructure,geometry,graph,networkflow,string,icpc,Atcoder">
<link rel="stylesheet" href="../../css/style.css">
<script type="text/javascript" src="../../js/openclose.js"></script>
<link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">
<link rel="stylesheet" href="../../css/prettify.css" type="text/css">
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>

<div id="container">

<header>
<h1 id="logo"><a href="../../index.html"><img src="../../images/logo.png" alt="kopricky アルゴリズムライブラリ"></a></h1>
</header>


<nav id="menubar">
<ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../guide.html">Guide</a></li>
<li class="current"><a href="../../code.html">Code</a></li>
<li><a href="../../link.html">Link</a></li>
</ul>
</nav>

<div id="contents">

<section>
<h2>RBST Query</h2>
<h3>コードについての説明</h3>
<p>
RBST とは randomized binary search tree の略で平衡二分木の乱択を用いた実装である. 2 つの二分木を merge する際にそれぞれの木のサイズに比例した確率で片方の木の根をもう一方の木の根につけるかを決める. <br>
こういう単純だけどうまくいく系はしっかりと解析することが大事なので考えてみるとよい気がする(<a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=F4F5586ACF14EFD688A8A58D032E79D0?doi=10.1.1.17.243&rep=rep1&type=pdf">参考</a>).
ただ, 完全に理解するの結構大変そうなので長い鎖になる確率は merge 条件を考えると急激に減少するしまあ期待値的には O(log n) になってくれるだろうという甘い理解にとどまっている.
加えて研究されているかどうかは知らないが, それなりに sharp な concentration が成り立つ気がしているので木が大きく平衡から外れるケースはめったになさそう？(怪)<br>
以下の実装では平衡二分木に遅延処理をのっけたデータ構造になっています. 具体的には範囲への加算 $a_i \leftarrow a_i + x (i \in [l, r)$ + 範囲の swap ($[a_p, a_q)$ と $[a_r, a_s)$ ($q-p = s-r$) を swap) のようなクエリなどを処理できます. <br>
また擬似乱数の生成に xor shift と呼ばれる手法を用いています(メルセンヌ・ツイスタとかだと遅くなるので). <br>
経験上, <a href="./splay_tree.html">Splay Tree</a> の方が速くなることが多い(入力で与えられた数列などから始める場合は bst_build で最初に完全平衡二分探索木を作ってから始めるとかなり速くなる). <br>
(追記) <br>
<a href="http://yosupo.hatenablog.com/entry/2015/10/30/115910">この記事</a> にあるように RBST の永続化は木が偏ってしまう可能性が高くなり適していない.
例えば偏った木と偏った木を merge させてできた木はさらに偏りが大きくなる可能性が高そうで,
記事のように自分と自分を merge させるというような操作を繰り返したときに自分がもし偏った木になった場合には自浄作用が働かず, 平衡状態に戻る確率は低くなると予想される.
</p>
<p>
時間計算量: insert, erase, get および 各クエリ $\O (\log n)$ (期待計算量)
</p>
<h3>コード</h3>
<div class="codebox">
<input type="checkbox" id="label" class="csscode" />
<label for="label"></label>
<pre class="prettyprint linenums">
// 返り値のノードはその木の新たな root として更新することを忘れない.
template&lt;typename _Tp&gt; class RBSTNode {
public:
    unsigned sz;
    _Tp val, lazy, al;
    RBSTNode* left, *right;
    RBSTNode(){};
    RBSTNode(_Tp v) : sz(1), val(v), lazy(id1), al(val), left(nullptr), right(nullptr){}
    static const _Tp id1 = (_Tp)0;
    static const _Tp id2 = (_Tp)0;
    static void opr1(_Tp&amp; arg1, const _Tp arg2){ arg1 = arg1 + arg2; }
    static _Tp opr2(const _Tp arg1, const _Tp arg2){ return arg1 + arg2; }
    void push(){
        if(lazy == id1) return;
        opr1(val, lazy), al += lazy * sz;
        if(left) opr1(left-&gt;lazy, lazy);
        if(right) opr1(right-&gt;lazy, lazy);
        lazy = id1;
    }
    void eval(){
        sz = 1, al = val;
        if(left) left-&gt;push(), sz += left-&gt;sz, al = opr2(left-&gt;al, al);
        if(right) right-&gt;push(), sz += right-&gt;sz, al = opr2(al, right-&gt;al);
    }
    static unsigned rnd(){
        static unsigned x = 123456789, y = 362436069, z = 521288629, w = 86675123;
        unsigned t = (x^(x&lt;&lt;11));
        x = y, y = z, z = w;
        return (w = (w^(w&gt;&gt;19))^(t^(t&gt;&gt;8)));
    }
};

template&lt;typename _Tp&gt;
inline unsigned size(RBSTNode&lt;_Tp&gt; *t){ return t ? t-&gt;sz : 0u; }

// r を根とする木内のすべてのキー値が l を根とする木内どのキー値よりも大きいというような場合に, その 2 つの木 merge させる.
template&lt;typename _Tp&gt;
RBSTNode&lt;_Tp&gt; *join(RBSTNode&lt;_Tp&gt; *l, RBSTNode&lt;_Tp&gt; *r){
    if(!l) return r;
    if(!r) return l;
    l-&gt;push(), r-&gt;push();
    if(RBSTNode&lt;_Tp&gt;::rnd() % (l-&gt;sz + r-&gt;sz) &lt; l-&gt;sz){
        return l-&gt;right = join(l-&gt;right, r), l-&gt;eval(), l;
    }else{
        return r-&gt;left = join(l, r-&gt;left), r-&gt;eval(), r;
    }
}

// n 点の木を頂点数 k の木, 頂点数 n-k の木に split する.
template&lt;typename _Tp&gt;
pair&lt;RBSTNode&lt;_Tp&gt;*, RBSTNode&lt;_Tp&gt;*&gt; split(RBSTNode&lt;_Tp&gt; *t, unsigned k){
    if(!t) return make_pair(nullptr, nullptr);
    t-&gt;push();
    if(!k) return make_pair(nullptr, t);
    if(k &lt;= size(t-&gt;left)){
        pair&lt;RBSTNode&lt;_Tp&gt;*, RBSTNode&lt;_Tp&gt;*&gt; s = split(t-&gt;left, k);
        return t-&gt;left = s.second, t-&gt;eval(), make_pair(s.first, t);
    }else{
        pair&lt;RBSTNode&lt;_Tp&gt;*, RBSTNode&lt;_Tp&gt;*&gt; s = split(t-&gt;right, k-size(t-&gt;left)-1);
        return t-&gt;right = s.first, t-&gt;eval(), make_pair(t, s.second);
    }
}

// k 番目に頂点 u(を根とする木) を insert する.
template&lt;typename _Tp&gt;
RBSTNode&lt;_Tp&gt;* insert(RBSTNode&lt;_Tp&gt; *root, RBSTNode&lt;_Tp&gt;* u, const unsigned k){
    auto s = split(root, k);
    return join(join(s.first, u), s.second);
}

// k 番目の要素を erase する.
template&lt;typename _Tp&gt;
RBSTNode&lt;_Tp&gt;* erase(RBSTNode&lt;_Tp&gt; *root, unsigned k){
    auto sl = split(root, k);
    auto sr = split(sl.second, 1);
    delete sr.first;
    return join(sl.first, sr.second);
}

// k 番目の頂点を取得する
template&lt;typename _Tp&gt;
pair&lt;RBSTNode&lt;_Tp&gt;*, _Tp&gt; get(RBSTNode&lt;_Tp&gt; *root, unsigned k){
    auto sr = split(root, k+1);
    auto sl = split(sr.first, k);
    auto lr = sl.second;
    _Tp res = lr-&gt;val;
    return make_pair(join(join(sl.first, lr), sr.second), res);
}

template&lt;typename _Tp&gt;
RBSTNode&lt;_Tp&gt; *range(RBSTNode&lt;_Tp&gt; *root, const unsigned l, const unsigned r, const _Tp x){
    if(l &gt;= r) return nullptr;
    auto sl = split(root, l);
    auto sr = split(sl.second, r-l);
    RBSTNode&lt;_Tp&gt;::opr1(sr.first-&gt;lazy, x);
    return join(join(sl.first, sr.first), sr.second);
}

template&lt;typename _Tp&gt;
pair&lt;RBSTNode&lt;_Tp&gt;*, _Tp&gt; query(RBSTNode&lt;_Tp&gt; *root, const unsigned l, const unsigned r){
    if(l &gt;= r) return make_pair(nullptr, (_Tp)RBSTNode&lt;_Tp&gt;::id2);
    auto sl = split(root, l);
    auto sr = split(sl.second, r-l);
    _Tp res = sr.first-&gt;al;
    return make_pair(join(join(sl.first, sr.first), sr.second), res);
}


// ヘルパー関数
template&lt;typename _Tp&gt;
RBSTNode&lt;_Tp&gt; *bst_build(vector&lt;RBSTNode&lt;_Tp&gt;*&gt;&amp; vec){
    RBSTNode&lt;_Tp&gt; *root = vec[0];
    int i, n = (int)vec.size(), st = 2, isolate = ((n % 4 == 1) ? (n-1) : -1);
    while(st &lt;= n){
        root = vec[st-1];
        for(i = st-1; i &lt; n; i += 2*st){
            vec[i]-&gt;left = vec[i-st/2];
            if(i+st/2 &lt; n) vec[i]-&gt;right = vec[i+st/2];
            else if(isolate &gt;= 0) vec[i]-&gt;right = vec[isolate];
            vec[i]-&gt;eval();
        }
        isolate = ((n % (4*st) &gt;= st &amp;&amp; (n % (4*st) &lt; 2*st)) ? (i-2*st): isolate);
        st &lt;&lt;= 1;
    }
    return root;
}
</pre>
<h3>verify 用の問題</h3>
<p>Atcoder : <a href="https://beta.atcoder.jp/contests/soundhound2018-summer-final-open/tasks/soundhound2018_summer_final_e">Hash Swapping</a>
  <a href="https://beta.atcoder.jp/contests/soundhound2018-summer-final-open/submissions/3165990">提出コード</a></p>
</section>

</div>
<!--/contents-->

<footer>
<small>Copyright&copy; <a href="../../index.html"> My Algorithm : kopricky アルゴリズムライブラリ </a> All Rights Reserved.</small>
<span class="pr">《<a href="https://template-party.com/" target="_blank">Web Design:Template-Party</a>》</span>
</footer>

<script src="../../js/prettify.js"></script>
<script src="../../js/lang-css.js"></script>
<!-- prettyPrint()関数を実行するため追加↓ -->
<script>prettyPrint();</script>

</div>
<!--/container-->

</body>
</html>
